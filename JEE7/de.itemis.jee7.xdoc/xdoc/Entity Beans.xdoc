chapter:EntityBeans[Entity Beans]

In der Modelldatei können Entity Beans über die Schlüsselwörter code[JEELANG][entity] und code[JEELANG][options] definiert werden.
Options sind spezielle Entity Beans, mit denen man Auswahllisten definieren kann. Die Auswahllisten können entweder editierbar sein,
oder als Enumeration festgelegt werden.

Eine einfache Entity Bean wird mit dem Schlüsselwort code[JEELANG][entity] eingeleitet. In ihr können beliebig viele Attribute benutzt
werden. Es können Text- und EMail-Felder als ID-Felder definiert werden. Wird kein ID-Feld definiert, wird automatisch ein
Integer-Attribut mit Namen id generiert. Eine einfache Definition sieht folgendermaßen aus:
code[JEELANG][
	entity Address
	{
		Text	street;
		Text	plz;
		Text	location;
	}
]

Nach einem Generatorlauf kann die Applikation deployed werden. Die Maske sieht dann wie folgt aus:

img[images/Entity1.jpg][][][]

Will man noch den Adresstyp zwischen privat und geschäftlich angeben, kann eine nicht editierbare code[JEELANG][option] benutzt werden.
Diese code[JEELANG][option] wird als Enumeration generiert. Als Werte können nur Textschlüssel verwendet werden. Diese Schlüssel
werden automatisch im Resource Bundle aller definierter Sprachen angelegt, falls sie noch nicht vorhanden sind. In der Address
Entity Bean wird der Adresstyp AddressOption als Attributtyp code[JEELANG][Option] eingebunden. In der Datenbank entsteht dadurch eine 1:1-Relation.

code[JEELANG][
options AddressOption
{
    "address.work",
    "address.home"
}
 
entity Address
{
    Text                 street;
    Text                 plz;
    Text                 location;
    Option AddressOption addressOption;
}
]

In der Maske wird dadurch eine Combobox generiert. Passt man noch die Resource Bundles unter e[$PROJECT_HOME/src/<package>/messages.properties]
an, sieht dann die Maske folgendermaßen aus:

img[images/Entity2.jpg][][][]

Die Generierung einer Combobox erfordert noch weitere Dinge im Hintergrund:
ol[
	item[Für die Combobox muss ein Value Converter für JSF generiert werden, der die Werte aus der XHTML-Maske in Entity Bean-IDs
	konvertiert.]
    item[Die Entity Beans müssen die Methoden equals() und hash() so überschreiben, dass Entity Beans mit denselben IDs als identisch
	angesehen werden, sonst funktioniert der Value Converter nicht.]
]
Es macht natürlich Sinn, dass es Personen gibt, in denen mehrere Adressen gespeichert werden. Damit wird das Modell um die Entity Bean
e[Person] ergänzt:

code[JEELANG][
entity Person
{
    Text id              login;
    Text                 name;
    Entity Address \[\]    addresses;
}
]

In dieser Entity Bean wird ein Textfeld als ID-Feld markiert. Dadurch gibt es kein automatisches Integer-ID-Feld mehr. Es darf nur
ein Feld als ID-Feld innerhalb einer Entity Bean gesetzt werden. Ferner wird mit dem Schlüsselwort Entity eine 1:n-Relation
eingeführt, um mehrere Adressen an die Entity Bean binden zu können. Dabei muss der Typ - in diesem Falle Address - mit den \[\]-Zeichen
markiert werden, sonst wäre die Relation nur 1:1. Die Maske für die Person Entity Bean sieht folgendermaßen aus:

img[images/Entity3.jpg][][][]

Klickt man auf den "Edit addresses"-Button, gelangt man in die schon bekannte Maske der e[Address] Entity Bean.

section:WeitereAttributtypen[Weitere Attributtypen]

Um Daten in einer Datenbank zu speichern, machen diverse Datentypen Sinn. Jedes Attribut besteht aus der Kombination Datentyp,
ergänzende Optionen Attributname und Transient-Flag. Wird ein Attribut abschließend mit dem transient-Schlüsselwort markiert, so wird
dieses Attribut nicht in der Datenbank gespeichert. In diesem Fall werden zwei Klassen für die Entity Bean gemäß den Generation Gap
Pattern generiert. Eine abstrakte Basisklasse enthält die Attribute der Entity Bean, die konkrete Klasse enthält Getter- und
Setter-Methoden für die transienten Attribute. Man kann die transienten Methoden dazu verwenden, um aus anderen Attributen Werte
zusammen zu bauen. Aus Vor- und Nachnamen kann man den gesamten Namen als transientes Attribut herleiten.

code[JEELANG][
entity Person
{
    Text id              login;
    Text                 forename;
    Text                 surename;
    Text                 name transient;
    Entity Address \[\]    addresses;
}
]

Daraus wird in der Datei e[$PROJECT_HOME/src/<package>/entites/Person.java]:
code[Java][
/*
 * Generated by Xtext/JEE6 Generator.
 * Copyright (C) 2013  itemis AG
 * $Id$
 */
package de.itemis.jee6.beispiel.entities;
import javax.persistence.*;
/**
 * This class implements the Person entity bean,
 */
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@Table(name = "Person")
public class Person extends AbstractPerson {
    private static final long serialVersionUID = 1L;
    /**
     * This method is a transient getter of the virtual property name.
     *
     * @return The computed value for property name.
     */
    @Transient
    @Override
    public String getName()
    {
        return getSurename() + ", " + getForename();
    }
}
]
Aus Gründen der Übersichtlichkeit wurde auf Prüfen von Null-Pointern verzichtet.
Im Folgenden werden die Attribute aufgelistet und erklärt.

section2:Text[Text]

Das Textattribut wurde schon ausführlich erklärt. Es hat die Syntax:

code[JEELANG][
	Text (id) <Name> (transient);
]

In einer XHTML-Seite wird aus der Modellzeile

code[JEELANG][
	Text subject;
]

im Formular folgendes Schnipsel generiert:

code[XML][
<tr>
    <td class="mid">
        <h:outputLabel for="subject" value="#{msg\['info.startup.subject'\]}"/>
    </td>
    <td>
        <h:inputText id="subject" label="#{msg\['info.startup.subject'\]}" maxlength="255" value="#{infoHandler.startup.subject}"/>
    </td>
</tr>
]

section2:Integer[Integer]

Integer-Datentypen werden durch das Schlüsselwort code[JEELANG][Int] gefolgt von einem Variablennamen eingeleitet. Im XHTML-Formular
wird dabei automatisch ein entsprechender Value Converter generiert, der den Inhalt des Eingabefeldes automatisch in einen Integer
umwandelt. Die Syntax lautet:

code[JEELANG][
	Int <Name> (transient);
]

Aus der Modellzeile

code[JEELANG][
	Int integerEntry;
]

wird folgendes Schnipsel im XHTML generiert:
code[XML][
<tr>
    <td class="mid">
        <h:outputLabel for="integerEntry" value="#{msg\['info.startup.integerentry'\]}"/>
    </td>
    <td>
        <h:inputText id="integerEntry" label="#{msg\['info.startup.integerentry'\]}" size="10" value="#{infoHandler.startup.integerEntry}"/>
    </td>
</tr>
]

section2:Number[Number]

Number-Datentypen werden durch das Schlüsselwort code[JEELANG][Number] gefolgt von einem Variablennamen eingeleitet. Java-seitig
wird dafür ein double generiert Im XHTML-Formular wird dabei automatisch ein entsprechender Value Converter generiert, der den
Inhalt des Eingabefeldes automatisch in eine Kommazahl umwandelt. Die Syntax lautet:

code[JEELANG][
	Number <Name> (transient);
]

Aus der Modellzeile

code[JEELANG][
	Number numberEntry;
]

wird folgendes Schnipsel im XHTML generiert:
code[XML][
<tr>
    <td class="mid">
        <h:outputLabel for="numberEntry" value="#{msg\['info.startup.numberentry'\]}"/>
    </td>
    <td>
        <h:inputText id="numberEntry" label="#{msg\['info.startup.numberentry'\]}" maxlength="10" value="#{infoHandler.startup.numberEntry}"/>
    </td>
</tr>
]

section2:EMail[E-Mail]

Ein E-Mail-Datentyp kann als ID geführt werden und ist im Prinzip ein Textfeld mit dem Unterschied, dass ein Validator die Eingabe auf das Format einer gültigen EMail-Adresse prüft. Die Syntax lautet:

code[JEELANG][
	Email (id) <Name> (transient);
]

In einer XHTML-Seite wird aus der Modellzeile

code[JEELANG][
	Email mail;
]

im Formular folgendes Schnipsel generiert:

code[XML][
<tr>
    <td class="mid">
        <h:outputLabel for="mail" value="#{msg\['info.startup.mail'\]}"/>
    </td>
    <td>
        <h:inputText id="mail" label="#{msg\['info.startup.mail'\]}" maxlength="255" value="#{infoHandler.startup.mail}">
            <f:validator validatorId="mailValidator"/>
        </h:inputText>
    </td>
</tr>
]

Man beachte, dass automatisch der mailValidator eingebunden ist, der sich in der JEE6-Utils-Bibliothek befindet.

section2:Clob[Clob]

Alle Textfelder werden in der Datenbank als Varchar angelegt, welche eine Längenbegrenzung auf 255 Zeichen beinhaltet. Wenn man
mehr braucht, muss ein sog. Character Large Object benutzt werden. Im XHTML-Formular wird daraus eine Textarea generiert. Java-seitig
ist dieser Datentyp wie Text und E-Mail ein java.lang.String. Die Syntax lautet:

code[JEELANG][
	Clob <Name> (transient);
]

In einer XHTML-Seite wird aus der Modellzeile

code[JEELANG][
	Clob clobEntry;
]

im Formular folgendes Schnipsel generiert:

code[XML][
<tr>
    <td class="top">
        <h:outputLabel for="clobEntry" value="#{msg\['info.startup.clobentry'\]}"/>
    </td>
    <td>
        <h:inputTextarea cols="32" id="clobEntry" label="#{msg\['info.startup.clobentry'\]}" rows="7" value="#{infoHandler.startup.clobEntry}"/>
    </td>
</tr>
]

section2:Blob[Blob]

Will man Binärdaten in der Datenbank speichern, muss man den Datentyp code[JEELANG][Blob] verwenden, der mit dem Schlüsselwort
code[JEELANG][Blob] benutzt wird. Java-seitig wird daraus ein byte\[\]-Array. In einer XHTML-Maske erscheinen Attribute dieses
Typs nicht. Die Syntax lautet:

code[JEELANG][
	Blob <Name> (transient);
]

e[Hinweis]
Aus Gründen der Performance sollten nicht zu große Binärdaten in einer Datenbank gespeichert werden. Große Datensätze bringt man
besser im Dateisystem unter.

section2:Boolean[Boolean]

Einen einfachen Booleschen Datentypen führt man mit dem Schlüsselwort code[JEELANG][Boolean] ein. Sollte der Attrributname active lauten, wird noch
weitere Funktionalität generiert. In der XHTML-Maske wird in der Liste ein Kommandolink ergänzt, mit dem der Aktivierungsstatus dieses
Attributes gewechselt werden kann. Das setzt weitere Methoden im Action Handler und im DAO voraus, die automatisch mit generiert werden.

code[XML][
<tr>
    <td class="mid">
        <h:outputLabel for="active" value="#{msg\['info.startup.active'\]}"/>
    </td>
    <td>
        <h:selectBooleanCheckbox id="active" label="#{msg\['info.startup.active'\]}" value="#{infoHandler.startup.active}"/>
    </td>
</tr>
]

section2:Timestamp[Timestamp]

Mit diesem Datentypen kann ein Zeitstempel bestehend aus Uhrzeit und Kalenderdatum in der Datenbank gespeichert werden. In der Entity
Bean wird hierfür der Datentyp codeRef[java.util.Date] verwendet. Über die Verwendung von Datumsangaben über Prepared Statements in EQL wird
in diesem Artikel berichtet. Wird dem Schlüsselwort code[JEELANG][Timestamp] noch ein code[JEELANG][auto] beigegeben, so wird automatisch beim erstmaligem Speichern
der Entity Bean das Erzeugungsdatum in dieses Attribut gespeichert. Benutzt man stattdessen oder zusätzlich noch das Schlüsselwort
code[JEELANG][update], wird bei jeder Änderung der Entity Bean in der Datenbank dieses Attribut auf den aktuellen Zeitstempel gebracht. Die Syntax
lautet:

code[JEELANG][
	Timestamp (auto) (update) <Name> (transient);
]

Für folgende Modellzeile

code[JEELANG][
	Timestamp timestamp1;
]

wird in der XHTML folgendes Schnipsel generiert:
code[XML][
<tr>
    <td class="mid">
        <h:outputLabel for="timestamp1" value="#{msg\['info.startup.timestamp1'\]}"/>
    </td>
    <td>
        <h:inputText id="timestamp1" label="#{msg\['info.startup.timestamp1'\]}" value="#{infoHandler.startup.timestamp1}" maxlength="10" styleClass="date">
            <f:convertDateTime pattern="dd.MM.yyyy" type="date"/>
        </h:inputText>
    </td>
</tr>
]

Wird beim code[JEELANG][Timestamp] das Schlüsselwort code[JEELANG][auto] oder code[JEELANG][update] ergänzt, wird kein
Formulareinstrag im XHTML generiert. Stattdessen werd in der Entity Bean entsprechende Methoden ergänzt:

code[Java][
@PrePersist
public void prePersist() {
    if (getCreation() == null) {
        setCreation(new Date());
    }
}
]
Durch den Test auf den Null Pointer kann vor der Persistierung der Entity Bean schon ein anderes Datum als Erzeugungsdatum
angegeben werden.
code[Java][
@PreUpdate
public void preUpdate() {
    setChanged(new Date());
}
]

Die Annotationen @PrePersist und @PreUpdate sind Bestandteile des JEE-Frameworks.

section2:Date[Date]

Mit diesem Datentypen kann ein Kalenderdatum in der Datenbank untergebracht werden. In der Entity Bean wird hierfür der Datentyp
codeRef[java.util.Date] verwendet. Über die Verwendung von Datumsangaben über Prepared Statements in EQL wird in diesem Artikel
berichtet. Die Syntax lautet:

code[JEELANG][
	Date <Name> (transient);
]

Eine automatische Aktualisierung bei Anlegen und Ändern dieses Attributtyps wie beim Timestamp existiert bei diesem Attributtypen nicht! Aus der Modellzeile

code[JEELANG][
	Date dateElement;
]
wird folgendes XHTML-Schnipsel generiert:
code[XML][
<tr>
    <td class="mid">
        <h:outputLabel for="dateElement" value="#{msg\['info.startup.dateelement'\]}"/>
    </td>
    <td>
        <h:inputText id="dateElement" label="#{msg\['info.startup.dateelement'\]}" value="#{infoHandler.startup.dateElement}" maxlength="10" styleClass="date">
            <f:convertDateTime pattern="dd.MM.yyyy" type="date"/>
        </h:inputText>
    </td>
</tr>
]

section2:Entity[Entity]

Mit diesem Attributtyp kann eine Relation auf eine andere Entity Bean modelliert werden. Die Syntax lautet:

code[JEELANG][
	Entity <Typ> (\[\]) <Name>;
]

Es wird zwischen einer 1:1- und einer 1:n-Relation unterschieden, indem dem Entity Typen das Symbol \[\] beigestellt wird.
Die 1:1-Relation wird in einem XHTML-Formular nicht dargestellt. Soll für diesen Fall eine Combobox zur Auswahl dargestellt werden,
muss das Attribut als code[JEELANG][Option ](s.u.) deklariert werden. Für eine 1:n-Relation wird ein Button bereitgestellt, in der
die Liste der Entity Beans bearbeitet werden kann.

section2:Option[Option]

Soll in einer Entity Bean eine 1:1-Relation in einer Combobox ausgewählt werden können, muss der entsprechende Attributtyp code[JEELANG][Option]
lauten. Die Syntax ist ähnlich dem code[JEELANG][Entity]-Attributtyp mit dem Unterschied, dass keine 1:n-Relation benutzt werden kann:

code[JEELANG][
	Option <Typ> <Name>;
]

Die als Option referenzierte Entity Bean kann sowohl eine Enumeration sein, als auch als editierbar gekennzeichnet sein. Im Modell
wird aus der Zeile

code[JEELANG][
	Option UserInfo      owner;
]

Der XHTML-Codeschnipsel:
code[XML][
<tr>
    <td class="mid">
        <h:outputLabel for="owner" value="#{msg\['ordering.orderposition.owner'\]}"/>
    </td>
    <td>
        <h:selectOneMenu converter="#{orderingHandler.userInfoConverter}" id="owner" label="#{msg\['ordering.orderposition.owner'\]}" value="#{orderingHandler.orderPosition.owner}">
            <f:selectItem itemLabel="#{msg.no_selection}" itemValue="\[NULL\]"/>
            <f:selectItems itemLabel="#{owner.name}" itemValue="#{owner}" value="#{orderingHandler.userInfoList}" var="owner"/>
        </h:selectOneMenu>
    </td>
</tr>
]

Der Action Handler stellt die Liste der möglichen Auswahlelemente bereit. In diesem Falle muss die Klasse OrderingHandler die
Methode getUserInfoList() bereitstellen. In dem Beispiel darf die 1:1-Relation den Wert null annehmen. Soll das nicht möglich sein,
muss das <f:selectItem>-Tag entfernt werden. Zusätzlich werden noch an der Entity Bean die Methoden hashCode() und equals() überladen.
Die von den generierten Action Handlern beinhalten den dazu passenden Value Converter. In diesem Beispiel stellt die Klasse
OrderingHandler über die Methode getUserInfoConverter() den Converter als innere Klasse UserInfoConverter zur Verfügung.

section2:History[History]

Eine code[JEELANG][History] ist eine spezielle Form der 1:n-Relation. Es können Einträge in diese Liste hinzugefügt werden,
allerdings keine gelöscht werden. Dadurch kann ein zeitlicher Verlauf zu einer Entity Bean nachgehalten werden.

e[Achtung!]
In einer Entity Bean kann nur eine Historie verwendet werden. Auch in darunterliegenden Entity Beans darf die Historie nicht mehr 
verwendet werden.

section2:Besonderheiten[Besonderheiten der generierten Entity Beans]

Die generierten Entity Beans bieten noch einige Eigenschaften, die den Umgang mit den Entity Beans vereinfachen. So wird die
toString()-Methode überladen, um alle Attribute der Entity Bean auf einfache Weise ausgeben zu können. Das ist für Logging-Zwecke
besonders sinnvoll.

Sämtliche Attribute und Methoden werden mit Javadoc-Kommentaren dokumentiert.

Wird in keinen Attribut das Schlüsselwort code[JEELANG][id] verwendet, wird automatisch eine ID-Spalte generiert, die die IDs aus
einer ID-Tabelle beziehen. Diese Form der ID-Generierung ist die kompatibelste Variante zwischen den Application Servern und den
verwendeten Datenbanken. Jede Tabelle erhält in der IDs-Tabelle eine eigene Zeile, in denen die ID-Ranges verwaltet werden.

code[Java][
private int id;
 
/**
 * This getter returns the ID of this entity bean. The ID of this entity bean is automatically
 * generated using the {@link TableGenerator} feature of the container.
 *
 * @return The ID of this entity bean.
 */
@Id
@TableGenerator(name = "StartupIDs", table = "IDs", pkColumnName = "id", valueColumnName = "value", pkColumnValue = "Startup", initialValue = 1, allocationSize = 10)
@GeneratedValue(strategy = GenerationType.TABLE, generator = "StartupIDs")
public int getId() {
    return id;
}
 
/**
 * This setter sets the ID of this entity bean. Generally its only used by the JEE6 container.
 *
 * @param id The ID to set.
 */
public void setId(final int id) {
    this.id = id;
}
]

Den Entity Beans können durch weitere Schlüsselwörter noch zusätzliche Eigenschaften hinzugefügt werden. Zu diesem Zweck empfiehlt
sich die Auflistung der Syntax:

code[JEELANG][
	entity <Name> (filterable) (cloneable) { <Attributes>+ } (persistence unit <Persistence-Unit>) ;
]

Wie die Attribute attributes aussehen müssen wurde ja schon beschrieben. Werden für Auswahllisten Optionen verwendet, sieht die Syntax leicht erweitert aus. Hier lautet die Syntax:

code[JEELANG][
	options <Name> (filterable) (cloneable) (editable { <Attributes>+ }) | ( { <Resource-Key>+ }) (persistence unit <Persistence-Unit>) ;
]

Hier werden im Wesentlichen zwei Varianten unterschieden:
ol[
	item[Nicht editierbare Enumerations]
    item[Editierbare Optionen]
]
Die nicht editierbaren Enumerations wurden weiter oben schon beispielhaft beschrieben. Um in einer XHTML eine andere Entity Bean
als 1:1-Relation in einer Auswahlbox auswählen zu können, muss die Referenz auf diese Entity Bean als Option-Attribut benutzt werden.
Sie unterscheiden sich ansonsten nicht von den üblichen Entity Beans, die mit dem entity-Schlüsselwort beschrieben werden.

Für alle Varianten gilt, dass man die erzeugte Entity Bean in eine andere Persistenz Unit hinzufügen kann. Es ist dabei zu beachten,
dass alle rekursiv enthaltenen Relationen auf andere Entity Beans auch in derselben Persistenz Unit sein müssen. Der Eclipse-Editor
quittiert das entsprechend mit einer Fehlermarkirung im Editor udn der Generatorlauf schlägt dementsprechend fehl. Lässt man die
Definition auf die Persistenz Unit weg, wird automatisch die erste aufgelistete gewählt.

section2:Ergebnislistenfiltern[Ergebnislisten filtern]

Speziell für die Suche von Entity Beans aus Ergebnislisten kann das Filterable-Interface benutzt werden. Dieses Interface erfordert
die Implementierung der Methode public boolean filter(String pattern, Locale locale). Wird das Schlüsselwort code[JEELANG][filterable]
gesetzt, wird die Entity Bean in eine abstrakte Klasse und eine konkrete Klasse generiert. Die konkrete Klasse muss dann die besagte
Methode filter() implementieren. Da Suchen in Java schneller vonstatten geht, als in der Datenbank, macht das java-seitige Filtern bei
relativ kleinen Datenmengen Sinn. Bei großen Datenmengen sollte nach wie vor auf Seiten der Datenbank gefiltert werden. Ein weiterer
Vorteil der filter()-Methode ist, dass auf transienten Attributen gesucht werden kann. Um die Möglichkeit zu haben, sprachabhängig zu
vergleichen oder zu suchen, wird der Methode filter() die entsprechende Locale mitgegeben. Ein Beispiel für eine 
filter()-Implementierung könnte so aussehen:

code[Java][
@Override
public boolean filter(String pattern, Locale locale)
{
    return getPosition().toLowerCase(locale).contains(pattern.toLowerCase(locale));
}
]

In diesem Beispiel wird abhängig von der übergebenen Locale nach einem Suchmuster pattern in einer Bestellposition gesucht. Die
Bestellposition ist ein transientes Attribut. Bestellposition und Suchmuster werden gemäß des verwendeten Locales in Kleinbuchstaben
umgewandelt. Die Implementierung der filter()-Methode reicht natürlich nicht aus. Es muss natürlich über eine Datenmenge gefiltert
werden. Das geschieht sinnvollerweise in einem Action Handler. Dort wird über das DAO eine Datenmenge bezogen, danach gefiltert und
an die übergeordnete XHTML-Seite übergeben. Eine solche getList()-Methode könnte folgendes Ausssehen haben:

code[Java][
/**
 * This method returns a {@link List} of filtered {@link OrderPosition} of the last orders
 * done with the selected {@link Distributor}.
 *
 * @return The {@link List} of filtered {@link OrderPosition} beans of the last orders done.
 */
public List<OrderPosition> lastOrderList()
{
    List<OrderPosition> lastOrderList = dao.getLastOrderList();
    FilteredList<OrderPosition> filtered = new FilteredList<OrderPosition>();
    filtered.addAll(lastOrderList, pattern, getExternalContext().getRequestLocale());
    return filtered;
}
]

Die Klasse FilteredList erweitert die Klasse ArrayList und ist in der link[JEE6-Utils][javadoc/]-Bibliothek enthalten. Sie kann nur Elemente
aufnehmen, die das Filterable-Interface implementieren. Die Klasse überlädt die Methoden add() und addAll(), in denen das
Filtern stattfindet. Es werden nur Elemente der Liste hinzugefügt, die bei Aufruf der Elementmethode filter() true zurückliefern.
Das Locale wird aus dem Request ermittelt und entspricht damit der im Browser eingestellten Sprache.

section2:EntityBeansklonen[Entity Beans klonen]

Unter Umständen kann es nötig sein, dass eine Entity Bean geklont wird. Ein Beispiel hierfür ist, wenn Bestellpositionen kopiert
werden sollen. In diesem Fall muss das Schlüsselwort clonable nach dem Namen der Entity Bean mitgegeben werden. Dabei wird die
Methode clone() überladen. Damit es mit der Datenbank keine Probleme gibt, wird das ID-Attribut gelöscht, um die geklonte Entity
Bean später neu persistieren zu können.