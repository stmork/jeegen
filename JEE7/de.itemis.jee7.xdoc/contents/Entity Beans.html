<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<title>Entity Beans</title>

<link href="book.css" rel="stylesheet" type="text/css">
<link href="code.css" rel="stylesheet" type="text/css">
<link rel="home" href="documentation.html" title="">
</head>
<body>
<a name="EntityBeans"></a>
<h1>Entity Beans</h1>
<p>
In der Modelldatei können Entity Beans über die Schlüsselwörter <span class="inlinecode"><span class="keyword">entity</span></span> und <span class="inlinecode"><span class="keyword">options</span></span> definiert werden.
Options sind spezielle Entity Beans, mit denen man Auswahllisten definieren kann. Die Auswahllisten können entweder editierbar sein,
oder als Enumeration festgelegt werden.
</p>
<p>
Eine einfache Entity Bean wird mit dem Schlüsselwort <span class="inlinecode"><span class="keyword">entity</span></span> eingeleitet. In ihr können beliebig viele Attribute benutzt
werden. Es können Text- und EMail-Felder als ID-Felder definiert werden. Wird kein ID-Feld definiert, wird automatisch ein
Integer-Attribut mit Namen id generiert. Eine einfache Definition sieht folgendermaßen aus:
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">entity</span>&nbsp;Address<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">Text</span>&nbsp;&nbsp;&nbsp;&nbsp;street;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">Text</span>&nbsp;&nbsp;&nbsp;&nbsp;plz;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">Text</span>&nbsp;&nbsp;&nbsp;&nbsp;location;<br/>
}
</p>
</div>
</div>
</p>
<p>
Nach einem Generatorlauf kann die Applikation deployed werden. Die Maske sieht dann wie folgt aus:
</p>
<p>
<div class="image" >
<img src="images/Entity1.jpg" 
/>
<div class="caption">
</div>
</div>
</p>
<p>
Will man noch den Adresstyp zwischen privat und geschäftlich angeben, kann eine nicht editierbare <span class="inlinecode"><span class="keyword">option</span></span> benutzt werden.
Diese <span class="inlinecode"><span class="keyword">option</span></span> wird als Enumeration generiert. Als Werte können nur Textschlüssel verwendet werden. Diese Schlüssel
werden automatisch im Resource Bundle aller definierter Sprachen angelegt, falls sie noch nicht vorhanden sind. In der Address
Entity Bean wird der Adresstyp AddressOption als Attributtyp <span class="inlinecode"><span class="keyword">Option</span></span> eingebunden. In der Datenbank entsteht dadurch eine 1:1-Relation.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">options</span>&nbsp;AddressOption<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"address.work"</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"address.home"</span><br/>
}<br/>
&nbsp;<br/>
<span class="keyword">entity</span>&nbsp;Address<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">Text</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;street;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">Text</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plz;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">Text</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">Option</span>&nbsp;AddressOption&nbsp;addressOption;<br/>
}
</p>
</div>
</div>
</p>
<p>
In der Maske wird dadurch eine Combobox generiert. Passt man noch die Resource Bundles unter <em>$PROJECT_HOME/src/&lt;package&gt;/messages.properties</em>
an, sieht dann die Maske folgendermaßen aus:
</p>
<p>
<div class="image" >
<img src="images/Entity2.jpg" 
/>
<div class="caption">
</div>
</div>
</p>
<p>
Die Generierung einer Combobox erfordert noch weitere Dinge im Hintergrund:
<ol>
	<li>
		Für die Combobox muss ein Value Converter für JSF generiert werden, der die Werte aus der XHTML-Maske in Entity Bean-IDs
			konvertiert.
	</li>
	<li>
		Die Entity Beans müssen die Methoden equals() und hash() so überschreiben, dass Entity Beans mit denselben IDs als identisch
			angesehen werden, sonst funktioniert der Value Converter nicht.
	</li>
</ol>

Es macht natürlich Sinn, dass es Personen gibt, in denen mehrere Adressen gespeichert werden. Damit wird das Modell um die Entity Bean
<em>Person</em> ergänzt:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">entity</span>&nbsp;Person<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">Text</span>&nbsp;<span class="keyword">id</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;login;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">Text</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">Entity</span>&nbsp;Address&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;addresses;<br/>
}
</p>
</div>
</div>
</p>
<p>
In dieser Entity Bean wird ein Textfeld als ID-Feld markiert. Dadurch gibt es kein automatisches Integer-ID-Feld mehr. Es darf nur
ein Feld als ID-Feld innerhalb einer Entity Bean gesetzt werden. Ferner wird mit dem Schlüsselwort Entity eine 1:n-Relation
eingeführt, um mehrere Adressen an die Entity Bean binden zu können. Dabei muss der Typ - in diesem Falle Address - mit den []-Zeichen
markiert werden, sonst wäre die Relation nur 1:1. Die Maske für die Person Entity Bean sieht folgendermaßen aus:
</p>
<p>
<div class="image" >
<img src="images/Entity3.jpg" 
/>
<div class="caption">
</div>
</div>
</p>
<p>
Klickt man auf den "Edit addresses"-Button, gelangt man in die schon bekannte Maske der <em>Address</em> Entity Bean.
</p>
<a name="WeitereAttributtypen"></a>
<h2>Weitere Attributtypen</h2>
<p>
Um Daten in einer Datenbank zu speichern, machen diverse Datentypen Sinn. Jedes Attribut besteht aus der Kombination Datentyp,
ergänzende Optionen Attributname und Transient-Flag. Wird ein Attribut abschließend mit dem transient-Schlüsselwort markiert, so wird
dieses Attribut nicht in der Datenbank gespeichert. In diesem Fall werden zwei Klassen für die Entity Bean gemäß den Generation Gap
Pattern generiert. Eine abstrakte Basisklasse enthält die Attribute der Entity Bean, die konkrete Klasse enthält Getter- und
Setter-Methoden für die transienten Attribute. Man kann die transienten Methoden dazu verwenden, um aus anderen Attributen Werte
zusammen zu bauen. Aus Vor- und Nachnamen kann man den gesamten Namen als transientes Attribut herleiten.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">entity</span>&nbsp;Person<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">Text</span>&nbsp;<span class="keyword">id</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;login;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">Text</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forename;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">Text</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;surename;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">Text</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;<span class="keyword">transient</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">Entity</span>&nbsp;Address&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;addresses;<br/>
}
</p>
</div>
</div>
</p>
<p>
Daraus wird in der Datei <em>$PROJECT_HOME/src/&lt;package&gt;/entites/Person.java</em>:
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="comment">/*<br/>
&nbsp;*&nbsp;Generated&nbsp;by&nbsp;Xtext/JEE6&nbsp;Generator.<br/>
&nbsp;*&nbsp;Copyright&nbsp;(C)&nbsp;2013&nbsp;&nbsp;itemis&nbsp;AG<br/>
&nbsp;*&nbsp;$Id$<br/>
&nbsp;*/</span><br/>
<span class="keyword">package</span>&nbsp;de.itemis.jee6.beispiel.entities;<br/>
<span class="keyword">import</span>&nbsp;javax.persistence.*;<br/>
<span class="comment">/**<br/>
&nbsp;*&nbsp;This&nbsp;class&nbsp;implements&nbsp;the&nbsp;Person&nbsp;entity&nbsp;bean,<br/>
&nbsp;*/</span><br/>
@Entity<br/>
@Inheritance(strategy&nbsp;=&nbsp;InheritanceType.SINGLE_TABLE)<br/>
@Table(name&nbsp;=&nbsp;<span class="string">"Person"</span>)<br/>
<span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;Person&nbsp;<span class="keyword">extends</span>&nbsp;AbstractPerson&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;<span class="keyword">static</span>&nbsp;<span class="keyword">final</span>&nbsp;<span class="keyword">long</span>&nbsp;serialVersionUID&nbsp;=&nbsp;1L;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/**<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;This&nbsp;method&nbsp;is&nbsp;a&nbsp;transient&nbsp;getter&nbsp;of&nbsp;the&nbsp;virtual&nbsp;property&nbsp;name.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;The&nbsp;computed&nbsp;value&nbsp;for&nbsp;property&nbsp;name.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;@Transient<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@Override<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;String&nbsp;getName()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;getSurename()&nbsp;+&nbsp;<span class="string">",&nbsp;"</span>&nbsp;+&nbsp;getForename();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}
</p>
</div>
</div>

Aus Gründen der Übersichtlichkeit wurde auf Prüfen von Null-Pointern verzichtet.
Im Folgenden werden die Attribute aufgelistet und erklärt.
</p>
<a name="Text"></a>
<h3>Text</h3>
<p>
Das Textattribut wurde schon ausführlich erklärt. Es hat die Syntax:
</p>
<p>
<span class="inlinecode"><span class="keyword">Text</span>&nbsp;(<span class="keyword">id</span>)&nbsp;&lt;Name&gt;&nbsp;(<span class="keyword">transient</span>);</span>
</p>
<p>
In einer XHTML-Seite wird aus der Modellzeile
</p>
<p>
<span class="inlinecode"><span class="keyword">Text</span>&nbsp;subject;</span>
</p>
<p>
im Formular folgendes Schnipsel generiert:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
&lt;tr&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&nbsp;class=<span class="string">"mid"</span>&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h:outputLabel&nbsp;for=<span class="string">"subject"</span>&nbsp;value=<span class="string">"#{msg[&apos;info.startup.subject&apos;]}"</span>/&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/td&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h:inputText&nbsp;id=<span class="string">"subject"</span>&nbsp;label=<span class="string">"#{msg[&apos;info.startup.subject&apos;]}"</span>&nbsp;maxlength=<span class="string">"255"</span>&nbsp;value=<span class="string">"#{infoHandler.startup.subject}"</span>/&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/td&gt;<br/>
&lt;/tr&gt;
</p>
</div>
</div>
</p>
<a name="Integer"></a>
<h3>Integer</h3>
<p>
Integer-Datentypen werden durch das Schlüsselwort <span class="inlinecode"><span class="keyword">Int</span></span> gefolgt von einem Variablennamen eingeleitet. Im XHTML-Formular
wird dabei automatisch ein entsprechender Value Converter generiert, der den Inhalt des Eingabefeldes automatisch in einen Integer
umwandelt. Die Syntax lautet:
</p>
<p>
<span class="inlinecode"><span class="keyword">Int</span>&nbsp;&lt;Name&gt;&nbsp;(<span class="keyword">transient</span>);</span>
</p>
<p>
Aus der Modellzeile
</p>
<p>
<span class="inlinecode"><span class="keyword">Int</span>&nbsp;integerEntry;</span>
</p>
<p>
wird folgendes Schnipsel im XHTML generiert:
<div class="literallayout">
<div class="incode">
<p class="code">
&lt;tr&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&nbsp;class=<span class="string">"mid"</span>&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h:outputLabel&nbsp;for=<span class="string">"integerEntry"</span>&nbsp;value=<span class="string">"#{msg[&apos;info.startup.integerentry&apos;]}"</span>/&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/td&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h:inputText&nbsp;id=<span class="string">"integerEntry"</span>&nbsp;label=<span class="string">"#{msg[&apos;info.startup.integerentry&apos;]}"</span>&nbsp;size=<span class="string">"10"</span>&nbsp;value=<span class="string">"#{infoHandler.startup.integerEntry}"</span>/&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/td&gt;<br/>
&lt;/tr&gt;
</p>
</div>
</div>
</p>
<a name="Number"></a>
<h3>Number</h3>
<p>
Number-Datentypen werden durch das Schlüsselwort <span class="inlinecode"><span class="keyword">Number</span></span> gefolgt von einem Variablennamen eingeleitet. Java-seitig
wird dafür ein double generiert Im XHTML-Formular wird dabei automatisch ein entsprechender Value Converter generiert, der den
Inhalt des Eingabefeldes automatisch in eine Kommazahl umwandelt. Die Syntax lautet:
</p>
<p>
<span class="inlinecode"><span class="keyword">Number</span>&nbsp;&lt;Name&gt;&nbsp;(<span class="keyword">transient</span>);</span>
</p>
<p>
Aus der Modellzeile
</p>
<p>
<span class="inlinecode"><span class="keyword">Number</span>&nbsp;numberEntry;</span>
</p>
<p>
wird folgendes Schnipsel im XHTML generiert:
<div class="literallayout">
<div class="incode">
<p class="code">
&lt;tr&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&nbsp;class=<span class="string">"mid"</span>&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h:outputLabel&nbsp;for=<span class="string">"numberEntry"</span>&nbsp;value=<span class="string">"#{msg[&apos;info.startup.numberentry&apos;]}"</span>/&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/td&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h:inputText&nbsp;id=<span class="string">"numberEntry"</span>&nbsp;label=<span class="string">"#{msg[&apos;info.startup.numberentry&apos;]}"</span>&nbsp;maxlength=<span class="string">"10"</span>&nbsp;value=<span class="string">"#{infoHandler.startup.numberEntry}"</span>/&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/td&gt;<br/>
&lt;/tr&gt;
</p>
</div>
</div>
</p>
<a name="EMail"></a>
<h3>E-Mail</h3>
<p>
Ein E-Mail-Datentyp kann als ID geführt werden und ist im Prinzip ein Textfeld mit dem Unterschied, dass ein Validator die Eingabe auf das Format einer gültigen EMail-Adresse prüft. Die Syntax lautet:
</p>
<p>
<span class="inlinecode"><span class="keyword">Email</span>&nbsp;(<span class="keyword">id</span>)&nbsp;&lt;Name&gt;&nbsp;(<span class="keyword">transient</span>);</span>
</p>
<p>
In einer XHTML-Seite wird aus der Modellzeile
</p>
<p>
<span class="inlinecode"><span class="keyword">Email</span>&nbsp;mail;</span>
</p>
<p>
im Formular folgendes Schnipsel generiert:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
&lt;tr&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&nbsp;class=<span class="string">"mid"</span>&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h:outputLabel&nbsp;for=<span class="string">"mail"</span>&nbsp;value=<span class="string">"#{msg[&apos;info.startup.mail&apos;]}"</span>/&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/td&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h:inputText&nbsp;id=<span class="string">"mail"</span>&nbsp;label=<span class="string">"#{msg[&apos;info.startup.mail&apos;]}"</span>&nbsp;maxlength=<span class="string">"255"</span>&nbsp;value=<span class="string">"#{infoHandler.startup.mail}"</span>&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;f:validator&nbsp;validatorId=<span class="string">"mailValidator"</span>/&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/h:inputText&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/td&gt;<br/>
&lt;/tr&gt;
</p>
</div>
</div>
</p>
<p>
Man beachte, dass automatisch der mailValidator eingebunden ist, der sich in der JEE6-Utils-Bibliothek befindet.
</p>
<a name="Clob"></a>
<h3>Clob</h3>
<p>
Alle Textfelder werden in der Datenbank als Varchar angelegt, welche eine Längenbegrenzung auf 255 Zeichen beinhaltet. Wenn man
mehr braucht, muss ein sog. Character Large Object benutzt werden. Im XHTML-Formular wird daraus eine Textarea generiert. Java-seitig
ist dieser Datentyp wie Text und E-Mail ein java.lang.String. Die Syntax lautet:
</p>
<p>
<span class="inlinecode"><span class="keyword">Clob</span>&nbsp;&lt;Name&gt;&nbsp;(<span class="keyword">transient</span>);</span>
</p>
<p>
In einer XHTML-Seite wird aus der Modellzeile
</p>
<p>
<span class="inlinecode"><span class="keyword">Clob</span>&nbsp;clobEntry;</span>
</p>
<p>
im Formular folgendes Schnipsel generiert:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
&lt;tr&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&nbsp;class=<span class="string">"top"</span>&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h:outputLabel&nbsp;for=<span class="string">"clobEntry"</span>&nbsp;value=<span class="string">"#{msg[&apos;info.startup.clobentry&apos;]}"</span>/&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/td&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h:inputTextarea&nbsp;cols=<span class="string">"32"</span>&nbsp;id=<span class="string">"clobEntry"</span>&nbsp;label=<span class="string">"#{msg[&apos;info.startup.clobentry&apos;]}"</span>&nbsp;rows=<span class="string">"7"</span>&nbsp;value=<span class="string">"#{infoHandler.startup.clobEntry}"</span>/&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/td&gt;<br/>
&lt;/tr&gt;
</p>
</div>
</div>
</p>
<a name="Blob"></a>
<h3>Blob</h3>
<p>
Will man Binärdaten in der Datenbank speichern, muss man den Datentyp <span class="inlinecode"><span class="keyword">Blob</span></span> verwenden, der mit dem Schlüsselwort
<span class="inlinecode"><span class="keyword">Blob</span></span> benutzt wird. Java-seitig wird daraus ein byte[]-Array. In einer XHTML-Maske erscheinen Attribute dieses
Typs nicht. Die Syntax lautet:
</p>
<p>
<span class="inlinecode"><span class="keyword">Blob</span>&nbsp;&lt;Name&gt;&nbsp;(<span class="keyword">transient</span>);</span>
</p>
<p>
<em>Hinweis</em>
Aus Gründen der Performance sollten nicht zu große Binärdaten in einer Datenbank gespeichert werden. Große Datensätze bringt man
besser im Dateisystem unter.
</p>
<a name="Boolean"></a>
<h3>Boolean</h3>
<p>
Einen einfachen Booleschen Datentypen führt man mit dem Schlüsselwort <span class="inlinecode"><span class="keyword">Boolean</span></span> ein. Sollte der Attrributname active lauten, wird noch
weitere Funktionalität generiert. In der XHTML-Maske wird in der Liste ein Kommandolink ergänzt, mit dem der Aktivierungsstatus dieses
Attributes gewechselt werden kann. Das setzt weitere Methoden im Action Handler und im DAO voraus, die automatisch mit generiert werden.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
&lt;tr&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&nbsp;class=<span class="string">"mid"</span>&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h:outputLabel&nbsp;for=<span class="string">"active"</span>&nbsp;value=<span class="string">"#{msg[&apos;info.startup.active&apos;]}"</span>/&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/td&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h:selectBooleanCheckbox&nbsp;id=<span class="string">"active"</span>&nbsp;label=<span class="string">"#{msg[&apos;info.startup.active&apos;]}"</span>&nbsp;value=<span class="string">"#{infoHandler.startup.active}"</span>/&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/td&gt;<br/>
&lt;/tr&gt;
</p>
</div>
</div>
</p>
<a name="Timestamp"></a>
<h3>Timestamp</h3>
<p>
Mit diesem Datentypen kann ein Zeitstempel bestehend aus Uhrzeit und Kalenderdatum in der Datenbank gespeichert werden. In der Entity
Bean wird hierfür der Datentyp <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/Date.html" title="View JavaDoc"><abbr title="java.util.Date" >Date</abbr></a> verwendet. Über die Verwendung von Datumsangaben über Prepared Statements in EQL wird
in diesem Artikel berichtet. Wird dem Schlüsselwort <span class="inlinecode"><span class="keyword">Timestamp</span></span> noch ein <span class="inlinecode"><span class="keyword">auto</span></span> beigegeben, so wird automatisch beim erstmaligem Speichern
der Entity Bean das Erzeugungsdatum in dieses Attribut gespeichert. Benutzt man stattdessen oder zusätzlich noch das Schlüsselwort
<span class="inlinecode"><span class="keyword">update</span></span>, wird bei jeder Änderung der Entity Bean in der Datenbank dieses Attribut auf den aktuellen Zeitstempel gebracht. Die Syntax
lautet:
</p>
<p>
<span class="inlinecode"><span class="keyword">Timestamp</span>&nbsp;(<span class="keyword">auto</span>)&nbsp;(<span class="keyword">update</span>)&nbsp;&lt;Name&gt;&nbsp;(<span class="keyword">transient</span>);</span>
</p>
<p>
Für folgende Modellzeile
</p>
<p>
<span class="inlinecode"><span class="keyword">Timestamp</span>&nbsp;timestamp1;</span>
</p>
<p>
wird in der XHTML folgendes Schnipsel generiert:
<div class="literallayout">
<div class="incode">
<p class="code">
&lt;tr&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&nbsp;class=<span class="string">"mid"</span>&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h:outputLabel&nbsp;for=<span class="string">"timestamp1"</span>&nbsp;value=<span class="string">"#{msg[&apos;info.startup.timestamp1&apos;]}"</span>/&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/td&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h:inputText&nbsp;id=<span class="string">"timestamp1"</span>&nbsp;label=<span class="string">"#{msg[&apos;info.startup.timestamp1&apos;]}"</span>&nbsp;value=<span class="string">"#{infoHandler.startup.timestamp1}"</span>&nbsp;maxlength=<span class="string">"10"</span>&nbsp;styleClass=<span class="string">"date"</span>&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;f:convertDateTime&nbsp;pattern=<span class="string">"dd.MM.yyyy"</span>&nbsp;type=<span class="string">"date"</span>/&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/h:inputText&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/td&gt;<br/>
&lt;/tr&gt;
</p>
</div>
</div>
</p>
<p>
Wird beim <span class="inlinecode"><span class="keyword">Timestamp</span></span> das Schlüsselwort <span class="inlinecode"><span class="keyword">auto</span></span> oder <span class="inlinecode"><span class="keyword">update</span></span> ergänzt, wird kein
Formulareinstrag im XHTML generiert. Stattdessen werd in der Entity Bean entsprechende Methoden ergänzt:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
@PrePersist<br/>
<span class="keyword">public</span>&nbsp;<span class="keyword">void</span>&nbsp;prePersist()&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(getCreation()&nbsp;==&nbsp;<span class="keyword">null</span>)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCreation(<span class="keyword">new</span>&nbsp;Date());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}
</p>
</div>
</div>

Durch den Test auf den Null Pointer kann vor der Persistierung der Entity Bean schon ein anderes Datum als Erzeugungsdatum
angegeben werden.
<div class="literallayout">
<div class="incode">
<p class="code">
@PreUpdate<br/>
<span class="keyword">public</span>&nbsp;<span class="keyword">void</span>&nbsp;preUpdate()&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;setChanged(<span class="keyword">new</span>&nbsp;Date());<br/>
}
</p>
</div>
</div>
</p>
<p>
Die Annotationen @PrePersist und @PreUpdate sind Bestandteile des JEE-Frameworks.
</p>
<a name="Date"></a>
<h3>Date</h3>
<p>
Mit diesem Datentypen kann ein Kalenderdatum in der Datenbank untergebracht werden. In der Entity Bean wird hierfür der Datentyp
<a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/Date.html" title="View JavaDoc"><abbr title="java.util.Date" >Date</abbr></a> verwendet. Über die Verwendung von Datumsangaben über Prepared Statements in EQL wird in diesem Artikel
berichtet. Die Syntax lautet:
</p>
<p>
<span class="inlinecode"><span class="keyword">Date</span>&nbsp;&lt;Name&gt;&nbsp;(<span class="keyword">transient</span>);</span>
</p>
<p>
Eine automatische Aktualisierung bei Anlegen und Ändern dieses Attributtyps wie beim Timestamp existiert bei diesem Attributtypen nicht! Aus der Modellzeile
</p>
<p>
<span class="inlinecode"><span class="keyword">Date</span>&nbsp;dateElement;</span>
wird folgendes XHTML-Schnipsel generiert:
<div class="literallayout">
<div class="incode">
<p class="code">
&lt;tr&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&nbsp;class=<span class="string">"mid"</span>&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h:outputLabel&nbsp;for=<span class="string">"dateElement"</span>&nbsp;value=<span class="string">"#{msg[&apos;info.startup.dateelement&apos;]}"</span>/&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/td&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h:inputText&nbsp;id=<span class="string">"dateElement"</span>&nbsp;label=<span class="string">"#{msg[&apos;info.startup.dateelement&apos;]}"</span>&nbsp;value=<span class="string">"#{infoHandler.startup.dateElement}"</span>&nbsp;maxlength=<span class="string">"10"</span>&nbsp;styleClass=<span class="string">"date"</span>&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;f:convertDateTime&nbsp;pattern=<span class="string">"dd.MM.yyyy"</span>&nbsp;type=<span class="string">"date"</span>/&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/h:inputText&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/td&gt;<br/>
&lt;/tr&gt;
</p>
</div>
</div>
</p>
<a name="Entity"></a>
<h3>Entity</h3>
<p>
Mit diesem Attributtyp kann eine Relation auf eine andere Entity Bean modelliert werden. Die Syntax lautet:
</p>
<p>
<span class="inlinecode"><span class="keyword">Entity</span>&nbsp;&lt;Typ&gt;&nbsp;([])&nbsp;&lt;Name&gt;;</span>
</p>
<p>
Es wird zwischen einer 1:1- und einer 1:n-Relation unterschieden, indem dem Entity Typen das Symbol [] beigestellt wird.
Die 1:1-Relation wird in einem XHTML-Formular nicht dargestellt. Soll für diesen Fall eine Combobox zur Auswahl dargestellt werden,
muss das Attribut als <span class="inlinecode"><span class="keyword">Option</span>&nbsp;</span>(s.u.) deklariert werden. Für eine 1:n-Relation wird ein Button bereitgestellt, in der
die Liste der Entity Beans bearbeitet werden kann.
</p>
<a name="Option"></a>
<h3>Option</h3>
<p>
Soll in einer Entity Bean eine 1:1-Relation in einer Combobox ausgewählt werden können, muss der entsprechende Attributtyp <span class="inlinecode"><span class="keyword">Option</span></span>
lauten. Die Syntax ist ähnlich dem <span class="inlinecode"><span class="keyword">Entity</span></span>-Attributtyp mit dem Unterschied, dass keine 1:n-Relation benutzt werden kann:
</p>
<p>
<span class="inlinecode"><span class="keyword">Option</span>&nbsp;&lt;Typ&gt;&nbsp;&lt;Name&gt;;</span>
</p>
<p>
Die als Option referenzierte Entity Bean kann sowohl eine Enumeration sein, als auch als editierbar gekennzeichnet sein. Im Modell
wird aus der Zeile
</p>
<p>
<span class="inlinecode"><span class="keyword">Option</span>&nbsp;UserInfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;owner;</span>
</p>
<p>
Der XHTML-Codeschnipsel:
<div class="literallayout">
<div class="incode">
<p class="code">
&lt;tr&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&nbsp;class=<span class="string">"mid"</span>&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h:outputLabel&nbsp;for=<span class="string">"owner"</span>&nbsp;value=<span class="string">"#{msg[&apos;ordering.orderposition.owner&apos;]}"</span>/&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/td&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h:selectOneMenu&nbsp;converter=<span class="string">"#{orderingHandler.userInfoConverter}"</span>&nbsp;id=<span class="string">"owner"</span>&nbsp;label=<span class="string">"#{msg[&apos;ordering.orderposition.owner&apos;]}"</span>&nbsp;value=<span class="string">"#{orderingHandler.orderPosition.owner}"</span>&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;f:selectItem&nbsp;itemLabel=<span class="string">"#{msg.no_selection}"</span>&nbsp;itemValue=<span class="string">"[NULL]"</span>/&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;f:selectItems&nbsp;itemLabel=<span class="string">"#{owner.name}"</span>&nbsp;itemValue=<span class="string">"#{owner}"</span>&nbsp;value=<span class="string">"#{orderingHandler.userInfoList}"</span>&nbsp;var=<span class="string">"owner"</span>/&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/h:selectOneMenu&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/td&gt;<br/>
&lt;/tr&gt;
</p>
</div>
</div>
</p>
<p>
Der Action Handler stellt die Liste der möglichen Auswahlelemente bereit. In diesem Falle muss die Klasse OrderingHandler die
Methode getUserInfoList() bereitstellen. In dem Beispiel darf die 1:1-Relation den Wert null annehmen. Soll das nicht möglich sein,
muss das &lt;f:selectItem&gt;-Tag entfernt werden. Zusätzlich werden noch an der Entity Bean die Methoden hashCode() und equals() überladen.
Die von den generierten Action Handlern beinhalten den dazu passenden Value Converter. In diesem Beispiel stellt die Klasse
OrderingHandler über die Methode getUserInfoConverter() den Converter als innere Klasse UserInfoConverter zur Verfügung.
</p>
<a name="History"></a>
<h3>History</h3>
<p>
Eine <span class="inlinecode"><span class="keyword">History</span></span> ist eine spezielle Form der 1:n-Relation. Es können Einträge in diese Liste hinzugefügt werden,
allerdings keine gelöscht werden. Dadurch kann ein zeitlicher Verlauf zu einer Entity Bean nachgehalten werden.
</p>
<p>
<em>Achtung!</em>
In einer Entity Bean kann nur eine Historie verwendet werden. Auch in darunterliegenden Entity Beans darf die Historie nicht mehr 
verwendet werden.
</p>
<a name="Besonderheiten"></a>
<h3>Besonderheiten der generierten Entity Beans</h3>
<p>
Die generierten Entity Beans bieten noch einige Eigenschaften, die den Umgang mit den Entity Beans vereinfachen. So wird die
toString()-Methode überladen, um alle Attribute der Entity Bean auf einfache Weise ausgeben zu können. Das ist für Logging-Zwecke
besonders sinnvoll.
</p>
<p>
Sämtliche Attribute und Methoden werden mit Javadoc-Kommentaren dokumentiert.
</p>
<p>
Wird in keinen Attribut das Schlüsselwort <span class="inlinecode"><span class="keyword">id</span></span> verwendet, wird automatisch eine ID-Spalte generiert, die die IDs aus
einer ID-Tabelle beziehen. Diese Form der ID-Generierung ist die kompatibelste Variante zwischen den Application Servern und den
verwendeten Datenbanken. Jede Tabelle erhält in der IDs-Tabelle eine eigene Zeile, in denen die ID-Ranges verwaltet werden.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">private</span>&nbsp;<span class="keyword">int</span>&nbsp;id;<br/>
&nbsp;<br/>
<span class="comment">/**<br/>
&nbsp;*&nbsp;This&nbsp;getter&nbsp;returns&nbsp;the&nbsp;ID&nbsp;of&nbsp;this&nbsp;entity&nbsp;bean.&nbsp;The&nbsp;ID&nbsp;of&nbsp;this&nbsp;entity&nbsp;bean&nbsp;is&nbsp;automatically<br/>
&nbsp;*&nbsp;generated&nbsp;using&nbsp;the&nbsp;{@link&nbsp;TableGenerator}&nbsp;feature&nbsp;of&nbsp;the&nbsp;container.<br/>
&nbsp;*<br/>
&nbsp;*&nbsp;@return&nbsp;The&nbsp;ID&nbsp;of&nbsp;this&nbsp;entity&nbsp;bean.<br/>
&nbsp;*/</span><br/>
@Id<br/>
@TableGenerator(name&nbsp;=&nbsp;<span class="string">"StartupIDs"</span>,&nbsp;table&nbsp;=&nbsp;<span class="string">"IDs"</span>,&nbsp;pkColumnName&nbsp;=&nbsp;<span class="string">"id"</span>,&nbsp;valueColumnName&nbsp;=&nbsp;<span class="string">"value"</span>,&nbsp;pkColumnValue&nbsp;=&nbsp;<span class="string">"Startup"</span>,&nbsp;initialValue&nbsp;=&nbsp;1,&nbsp;allocationSize&nbsp;=&nbsp;10)<br/>
@GeneratedValue(strategy&nbsp;=&nbsp;GenerationType.TABLE,&nbsp;generator&nbsp;=&nbsp;<span class="string">"StartupIDs"</span>)<br/>
<span class="keyword">public</span>&nbsp;<span class="keyword">int</span>&nbsp;getId()&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;id;<br/>
}<br/>
&nbsp;<br/>
<span class="comment">/**<br/>
&nbsp;*&nbsp;This&nbsp;setter&nbsp;sets&nbsp;the&nbsp;ID&nbsp;of&nbsp;this&nbsp;entity&nbsp;bean.&nbsp;Generally&nbsp;its&nbsp;only&nbsp;used&nbsp;by&nbsp;the&nbsp;JEE6&nbsp;container.<br/>
&nbsp;*<br/>
&nbsp;*&nbsp;@param&nbsp;id&nbsp;The&nbsp;ID&nbsp;to&nbsp;set.<br/>
&nbsp;*/</span><br/>
<span class="keyword">public</span>&nbsp;<span class="keyword">void</span>&nbsp;setId(<span class="keyword">final</span>&nbsp;<span class="keyword">int</span>&nbsp;id)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.id&nbsp;=&nbsp;id;<br/>
}
</p>
</div>
</div>
</p>
<p>
Den Entity Beans können durch weitere Schlüsselwörter noch zusätzliche Eigenschaften hinzugefügt werden. Zu diesem Zweck empfiehlt
sich die Auflistung der Syntax:
</p>
<p>
<span class="inlinecode"><span class="keyword">entity</span>&nbsp;&lt;Name&gt;&nbsp;(<span class="keyword">filterable</span>)&nbsp;(<span class="keyword">cloneable</span>)&nbsp;{&nbsp;&lt;Attributes&gt;+&nbsp;}&nbsp;(<span class="keyword">persistence</span>&nbsp;<span class="keyword">unit</span>&nbsp;&lt;Persistence-Unit&gt;)&nbsp;;</span>
</p>
<p>
Wie die Attribute attributes aussehen müssen wurde ja schon beschrieben. Werden für Auswahllisten Optionen verwendet, sieht die Syntax leicht erweitert aus. Hier lautet die Syntax:
</p>
<p>
<span class="inlinecode"><span class="keyword">options</span>&nbsp;&lt;Name&gt;&nbsp;(<span class="keyword">filterable</span>)&nbsp;(<span class="keyword">cloneable</span>)&nbsp;(<span class="keyword">editable</span>&nbsp;{&nbsp;&lt;Attributes&gt;+&nbsp;})&nbsp;|&nbsp;(&nbsp;{&nbsp;&lt;Resource-Key&gt;+&nbsp;})&nbsp;(<span class="keyword">persistence</span>&nbsp;<span class="keyword">unit</span>&nbsp;&lt;Persistence-Unit&gt;)&nbsp;;</span>
</p>
<p>
Hier werden im Wesentlichen zwei Varianten unterschieden:
<ol>
	<li>
		Nicht editierbare Enumerations
	</li>
	<li>
		Editierbare Optionen
	</li>
</ol>

Die nicht editierbaren Enumerations wurden weiter oben schon beispielhaft beschrieben. Um in einer XHTML eine andere Entity Bean
als 1:1-Relation in einer Auswahlbox auswählen zu können, muss die Referenz auf diese Entity Bean als Option-Attribut benutzt werden.
Sie unterscheiden sich ansonsten nicht von den üblichen Entity Beans, die mit dem entity-Schlüsselwort beschrieben werden.
</p>
<p>
Für alle Varianten gilt, dass man die erzeugte Entity Bean in eine andere Persistenz Unit hinzufügen kann. Es ist dabei zu beachten,
dass alle rekursiv enthaltenen Relationen auf andere Entity Beans auch in derselben Persistenz Unit sein müssen. Der Eclipse-Editor
quittiert das entsprechend mit einer Fehlermarkirung im Editor udn der Generatorlauf schlägt dementsprechend fehl. Lässt man die
Definition auf die Persistenz Unit weg, wird automatisch die erste aufgelistete gewählt.
</p>
<a name="Ergebnislistenfiltern"></a>
<h3>Ergebnislisten filtern</h3>
<p>
Speziell für die Suche von Entity Beans aus Ergebnislisten kann das Filterable-Interface benutzt werden. Dieses Interface erfordert
die Implementierung der Methode public boolean filter(String pattern, Locale locale). Wird das Schlüsselwort <span class="inlinecode"><span class="keyword">filterable</span></span>
gesetzt, wird die Entity Bean in eine abstrakte Klasse und eine konkrete Klasse generiert. Die konkrete Klasse muss dann die besagte
Methode filter() implementieren. Da Suchen in Java schneller vonstatten geht, als in der Datenbank, macht das java-seitige Filtern bei
relativ kleinen Datenmengen Sinn. Bei großen Datenmengen sollte nach wie vor auf Seiten der Datenbank gefiltert werden. Ein weiterer
Vorteil der filter()-Methode ist, dass auf transienten Attributen gesucht werden kann. Um die Möglichkeit zu haben, sprachabhängig zu
vergleichen oder zu suchen, wird der Methode filter() die entsprechende Locale mitgegeben. Ein Beispiel für eine 
filter()-Implementierung könnte so aussehen:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
@Override<br/>
<span class="keyword">public</span>&nbsp;<span class="keyword">boolean</span>&nbsp;filter(String&nbsp;pattern,&nbsp;Locale&nbsp;locale)<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;getPosition().toLowerCase(locale).contains(pattern.toLowerCase(locale));<br/>
}
</p>
</div>
</div>
</p>
<p>
In diesem Beispiel wird abhängig von der übergebenen Locale nach einem Suchmuster pattern in einer Bestellposition gesucht. Die
Bestellposition ist ein transientes Attribut. Bestellposition und Suchmuster werden gemäß des verwendeten Locales in Kleinbuchstaben
umgewandelt. Die Implementierung der filter()-Methode reicht natürlich nicht aus. Es muss natürlich über eine Datenmenge gefiltert
werden. Das geschieht sinnvollerweise in einem Action Handler. Dort wird über das DAO eine Datenmenge bezogen, danach gefiltert und
an die übergeordnete XHTML-Seite übergeben. Eine solche getList()-Methode könnte folgendes Ausssehen haben:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="comment">/**<br/>
&nbsp;*&nbsp;This&nbsp;method&nbsp;returns&nbsp;a&nbsp;{@link&nbsp;List}&nbsp;of&nbsp;filtered&nbsp;{@link&nbsp;OrderPosition}&nbsp;of&nbsp;the&nbsp;last&nbsp;orders<br/>
&nbsp;*&nbsp;done&nbsp;with&nbsp;the&nbsp;selected&nbsp;{@link&nbsp;Distributor}.<br/>
&nbsp;*<br/>
&nbsp;*&nbsp;@return&nbsp;The&nbsp;{@link&nbsp;List}&nbsp;of&nbsp;filtered&nbsp;{@link&nbsp;OrderPosition}&nbsp;beans&nbsp;of&nbsp;the&nbsp;last&nbsp;orders&nbsp;done.<br/>
&nbsp;*/</span><br/>
<span class="keyword">public</span>&nbsp;List&lt;OrderPosition&gt;&nbsp;lastOrderList()<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;List&lt;OrderPosition&gt;&nbsp;lastOrderList&nbsp;=&nbsp;dao.getLastOrderList();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;FilteredList&lt;OrderPosition&gt;&nbsp;filtered&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;FilteredList&lt;OrderPosition&gt;();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;filtered.addAll(lastOrderList,&nbsp;pattern,&nbsp;getExternalContext().getRequestLocale());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;filtered;<br/>
}
</p>
</div>
</div>
</p>
<p>
Die Klasse FilteredList erweitert die Klasse ArrayList und ist in der <a href="JEE6-Utils">javadoc/</a>-Bibliothek enthalten. Sie kann nur Elemente
aufnehmen, die das Filterable-Interface implementieren. Die Klasse überlädt die Methoden add() und addAll(), in denen das
Filtern stattfindet. Es werden nur Elemente der Liste hinzugefügt, die bei Aufruf der Elementmethode filter() true zurückliefern.
Das Locale wird aus dem Request ermittelt und entspricht damit der im Browser eingestellten Sprache.
</p>
<a name="EntityBeansklonen"></a>
<h3>Entity Beans klonen</h3>
<p>
Unter Umständen kann es nötig sein, dass eine Entity Bean geklont wird. Ein Beispiel hierfür ist, wenn Bestellpositionen kopiert
werden sollen. In diesem Fall muss das Schlüsselwort clonable nach dem Namen der Entity Bean mitgegeben werden. Dabei wird die
Methode clone() überladen. Damit es mit der Datenbank keine Probleme gibt, wird das ID-Attribut gelöscht, um die geklonte Entity
Bean später neu persistieren zu können.
</p>
</body>
</html>
