«REM»
«###»	Copyright (C) 2012 itemis AG
«###»	$Id$
«ENDREM»

«IMPORT jee6»

«EXTENSION de::itemis::jee6::generator::ext::bundle»
«EXTENSION de::itemis::jee6::generator::ext::entity»
«EXTENSION de::itemis::jee6::generator::ext::model»
«EXTENSION de::itemis::jee6::generator::ext::types»
«EXTENSION de::itemis::jee6::generator::ext::naming»
«EXTENSION de::itemis::jee6::generator::ext::converter»
«EXTENSION de::itemis::jee6::generator::ext::dao»
«EXTENSION de::itemis::jee6::generator::ext::ui»

«DEFINE Main FOR Model»
«EXPAND AbstractModelHandler»
«EXPAND AbstractProcessHandler FOREACH processes»
«EXPAND ProcessHandler FOREACH processes»
«EXPAND ApplicationController»
«EXPAND SessionController»
«ENDDEFINE»

«DEFINE AbstractProcessHandler FOR Process»
«FILE abstractHandlerFilename(this)»
«EXPAND utility::Header»
«LET getUiEntities() AS entities»
package «handlerPackageOf(this)»;

import javax.ejb.EJB;
import «fqDaoOf()»;
«IF entities.size > 0»
import java.util.List;
«ENDIF»
«FOREACH entities AS entity»
import «fqTypeOf(entity)»;
«ENDFOREACH»

«IF roles.size > 0»
import javax.faces.context.ExternalContext;
«ENDIF»

abstract public class «abstractHandlerOf(this)» extends «abstractHandlerOf(getModel(this))»
{
	private static final long serialVersionUID = 1L;

	@EJB
	protected «daoOf()» dao;

	public boolean isAllowed()
	{
«IF roles.size > 0»
		final ExternalContext context = getExternalContext();

		return
«FOREACH roles AS role SEPARATOR " || "»
			context.isUserInRole("«role»")
«ENDFOREACH»;
«ELSE»
		return true;
«ENDIF»
	}

«FOREACH entities AS entity»
	/*********************************************
	 * «typeOf(entity)» «nameOf(entity)»
	 *********************************************/

	private «typeOf(entity)» «nameOf(entity)» = new «typeOf(entity)»();

	public «typeOf(entity)» «getterOf(entity)»()
	{
		return «nameOf(entity)»;
	}	

	public void «setterOf(entity)»(final «typeOf(entity)» «nameOf(entity)»)
	{
		this.«nameOf(entity)» = «nameOf(entity)»;
	}

«IF isAbstract()»
	abstract public List<«typeOf(entity)»> «listOf(entity)»();
	abstract String «createEntity(entity)»(final «typeOf(entity)» «nameOf(entity)»);
	abstract String «editEntity(entity)»(final «typeOf(entity)» «nameOf(entity)»);
	abstract String «saveEntity(entity)»();
	abstract String «removeEntity(entity)»(final «typeOf(entity)» «nameOf(entity)»);
«IF hasActivationBoolean(entity)»
	abstract String «reactivateEntity(entity)»(final «typeOf(entity)» «nameOf(entity)»);
«ENDIF»
«ENDIF»
«ENDFOREACH»
}
«ENDLET»
«ENDFILE»
«ENDDEFINE»

«DEFINE ProcessHandler FOR Process»
«FILE handlerFilename(this) IMPL»
«LET getUiEntities() AS entities»
«EXPAND utility::Header»
package «handlerPackageOf(this)»;

import javax.faces.bean.ManagedBean;
import javax.faces.bean.SessionScoped;
«IF entities.size > 0»
import java.util.List;
«ENDIF»
«FOREACH entities AS entity»
import «fqTypeOf(entity)»;
«ENDFOREACH»

@ManagedBean
@SessionScoped
public class «handlerOf(this)» extends «abstractHandlerOf(this)»
{
	private static final long serialVersionUID = 1L;

«FOREACH entities AS entity»
	/*********************************************
	 * «typeOf(entity)» «nameOf(entity)»
	 *********************************************/

«IF isAbstract()»
	@Override
«ENDIF»
	public List<«typeOf(entity)»> «listOf(entity)»()
	{
		return dao.«listOf(entity)»();
	} 

«IF isAbstract()»
	@Override
«ENDIF»
	public String «createEntity(entity)»(final «typeOf(entity)» «nameOf(entity)») {
		dao.«adder(entity)»(«nameOf(entity)»);
		«setterOf(entity)»(new «typeOf(entity)»());
		return "«index(entity)»";
	}

«IF isAbstract()»
	@Override
«ENDIF»
	public String «editEntity(entity)»(final «typeOf(entity)» «nameOf(entity)») {
		«setterOf(entity)»(«nameOf(entity)»);
		return "«index(entity)»";
	}

«IF isAbstract()»
	@Override
«ENDIF»
	public String «saveEntity(entity)»() {
		dao.«updater(entity)»(«getterOf(entity)»());
		«setterOf(entity)»(new «typeOf(entity)»());
		return "«index(entity)»";
	}

«IF isAbstract()»
	@Override
«ENDIF»
	public String «removeEntity(entity)»(final «typeOf(entity)» «nameOf(entity)») {
		dao.«remover(entity)»(«nameOf(entity)»);
		return "«index(entity)»";
	}

«IF hasActivationBoolean(entity)»
«IF isAbstract()»
	@Override
«ENDIF»
	public String «reactivateEntity(entity)»(final «typeOf(entity)» «nameOf(entity)») {
		dao.activate(«nameOf(entity)», !«nameOf(entity)».isActive());
		return "«index(entity)»";
	}
«ENDIF»
«ENDFOREACH»
}
«ENDLET»
«ENDFILE»
«ENDDEFINE»

«DEFINE AbstractModelHandler FOR Model»
«FILE abstractHandlerFilename(this)»
«LET entities.typeSelect(Options) AS converterList»
«EXPAND utility::Header»
package «handlerPackageOf(this)»;

import java.io.Serializable;
import java.text.MessageFormat;
import java.text.NumberFormat;
import java.util.Calendar;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.ResourceBundle;

import javax.annotation.PostConstruct;
import javax.faces.application.FacesMessage;
import javax.faces.application.ProjectStage;
import javax.faces.context.ExternalContext;
import javax.faces.context.FacesContext;
import javax.faces.validator.ValidatorException;
import javax.servlet.http.HttpSession;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import de.itemis.jee6.util.ErrorInfo;
import de.itemis.jee6.util.ResourceBundleDefinitions;

«IF converterList.size > 0»
import javax.faces.component.UIComponent;
import javax.faces.convert.Converter;
import javax.ejb.EJB;
import «fqDaoOf()»;
«FOREACH converterList AS option»
import «fqTypeOf(option)»;
«ENDFOREACH»
«ENDIF»

abstract public class «abstractHandlerOf(this)» implements Serializable, ResourceBundleDefinitions
{
	private static final long serialVersionUID    = 1L;
	private static final Log  log                 = LogFactory.getLog(AbstractHandler.class);

	protected static final NumberFormat money     = NumberFormat.getCurrencyInstance();
	protected static final String       NAV_INDEX = "«index()»";
	protected static final String       NULL      = "[NULL]";

	private ResourceBundle messages;
	private ResourceBundle errors;
	protected boolean production;

«IF converterList.size > 0»
	@EJB
	protected «daoOf()» options;
«ENDIF»

	@PostConstruct
	public void getBundles()
	{
		log.debug("<getBundles()");
		FacesContext context = FacesContext.getCurrentInstance();
		messages   = context.getApplication().getResourceBundle(context, BUNDLE_MESSAGES);
		errors     = context.getApplication().getResourceBundle(context, BUNDLE_ERRORS);
		production = context.getApplication().getProjectStage() == ProjectStage.Production;

		if (log.isDebugEnabled())
		{
			ExternalContext external = context.getExternalContext();
			log.trace(" default: " + Locale.getDefault());
			log.trace(" req.:    " + external.getRequestLocale());
			Iterator<Locale> locales = external.getRequestLocales();
			if (locales != null)
			{
				while(locales.hasNext())
				{
					Locale locale = locales.next();
					log.trace(" o " + locale);
				}
			}
			log.trace(" msg: " + messages.getLocale());
			log.trace(" err: " + errors.getLocale());
		}
		log.debug(">getBundles()");
	}


«FOREACH converterList AS option»
	/**********************************
	 * «typeOf(option)» converter
	 **********************************/
	private final «converterOf(option)» «nameOf(option)» = new «converterOf(option)»();

	private class «converterOf(option)» implements Converter
	{
«LET getId(option) AS id»
		@Override
		public Object getAsObject(final FacesContext context, final UIComponent component, final String input)
		{
«IF id == null»
			return isNull(input) ? null : options.«finderOf(option)»(Integer.parseInt(input));
«ELSE»
			return isNull(input) ? null : options.«finderOf(option)»(input);
«ENDIF»
		}

		@Override
		public String getAsString(FacesContext context, UIComponent component, Object input)
		{
			final String result;
			
			if (isNull(input))
			{
				result = NULL;
			}
			else
			{
				final «typeOf(option)» option = («typeOf(option)»)input;
«IF id == null»
				result = Integer.toString(option.getId());
«ELSE»
				result = option.«getterOf(id)»();
«ENDIF»
			}
			return result;
		}
«ENDLET»
	}
	
	public List<«typeOf(option)»> «listOf(option)»()
	{
		return options.«listOf(option)»();
	}
	
«IF hasActivationBoolean(option)»
	public List<«typeOf(option)»> «listActiveOf(option)»()
	{
		return options.«listActiveOf(option)»();
	}
«ENDIF»
	
	public «converterOf(option)» «converterGetter(option)»()
	{
		return «nameOf(option)»;
	}
«ENDFOREACH»

	/***********************
	 *      utilities      *
	 ***********************/

	protected static boolean isNull(final Object input)
	{
		return (input == null) || NULL.equals(input);
	}

	protected final ExternalContext getExternalContext()
	{
		final FacesContext context = FacesContext.getCurrentInstance();

		return context != null ? context.getExternalContext() : null;
	}

	protected final String getInitParameter(final String key)
	{
		return getExternalContext().getInitParameter(key);
	}

	protected final HttpSession getSession()
	{
		ExternalContext context = getExternalContext();
		
		return context != null ? (HttpSession) context.getSession(false) : null;
	}

	public boolean isLoggedIn()
	{
		return getExternalContext().getRemoteUser() != null;
	}
	
	protected String getMessage(final String key, final Object ... params)
	{
		return MessageFormat.format(messages.getString(key), params);
	}
	
	protected String getError(final String key, final Object ... params)
	{
		final String message = MessageFormat.format(errors.getString(key), params); 
		log.debug(message);
		return message;
	}
	
	public String getYesNo(final boolean flag)
	{
		return messages.getString(flag ? "yes" : "no");
	}

	protected String error(final String id, final String key, final Object ... params)
	{
		final FacesContext context = FacesContext.getCurrentInstance();
		final String text = getError(key, params);
		final FacesMessage msg = new FacesMessage(text);
		msg.setSeverity(FacesMessage.SEVERITY_ERROR);
		context.addMessage(id, msg);
		return text;
	}

	protected void addErrors(List<ErrorInfo> errors)
	{
		final FacesContext context = FacesContext.getCurrentInstance();
		
		for (ErrorInfo info : errors)
		{
			final String text = getError(info.getMessageKey());
			final FacesMessage msg = new FacesMessage(text);
			msg.setSeverity(FacesMessage.SEVERITY_ERROR);
			context.addMessage(info.getGuiItemId(), msg);
		}		
	}
	
	public String back()
	{
		return NAV_INDEX;
	}

	public int getActYear()
	{
		return Calendar.getInstance().get(Calendar.YEAR);
	}

	protected int getMessageCount()
	{
		return FacesContext.getCurrentInstance().getMessageList().size();
	}

	protected void validationError(final String key, final Object ... params)
	{
		FacesMessage msg = new FacesMessage(getError(key, params));
		msg.setSeverity(FacesMessage.SEVERITY_ERROR);
		throw new ValidatorException(msg);
	}
}
«ENDLET»
«ENDFILE»
«ENDDEFINE»

«DEFINE ApplicationController FOR Model»
«FILE applicationControllerFilename() IMPL»
«EXPAND utility::Header»
package «controllerPackageOf()»;

import java.io.Serializable;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.annotation.PostConstruct;
import javax.faces.bean.ApplicationScoped;
import javax.faces.bean.ManagedBean;

import de.itemis.jee6.util.LogUtil;

@ManagedBean(eager=true)
@ApplicationScoped
public class «applicationController()» implements Serializable
{
	private static final long serialVersionUID = 1L;
	private final static Log log = LogFactory.getLog(«applicationController()».class);

	@PostConstruct
	public void init()
	{
		log.info("\n" + LogUtil.banner("«versionBundle()»", "«name»"));
		log.debug(">init()");
		log.debug("<init()");
	}
}
«ENDFILE»
«ENDDEFINE»

«DEFINE SessionController FOR Model»
«FILE sessionControllerFilename() IMPL»
«EXPAND utility::Header»
package «controllerPackageOf()»;

import javax.faces.bean.ManagedBean;
import «fqAbstractHandlerOf()»;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;

@ManagedBean
public class «sessionController()» extends «abstractHandlerOf()»
{
	private static final long serialVersionUID = 1L;

	public String logout(final HttpServletRequest request) throws ServletException
	{
		request.logout();
		getExternalContext().invalidateSession();

		return "/«index()»";
	}

	public boolean isLoggedIn()
	{
		return getExternalContext().getRemoteUser() != null;
	}
	
	public String getName()
	{
		final String login = getExternalContext().getRemoteUser();

		return login != null ? login : "<???>";
	}
}
«ENDFILE»
«ENDDEFINE»
