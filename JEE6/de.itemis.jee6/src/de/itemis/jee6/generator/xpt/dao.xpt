«IMPORT jee6»

«EXTENSION de::itemis::jee6::generator::ext::entity»
«EXTENSION de::itemis::jee6::generator::ext::model»
«EXTENSION de::itemis::jee6::generator::ext::types»
«EXTENSION de::itemis::jee6::generator::ext::naming»
«EXTENSION de::itemis::jee6::generator::ext::converter»
«EXTENSION de::itemis::jee6::generator::ext::dao»

«DEFINE Main FOR Model»
«EXPAND AbstractDao FOREACH processes»
«EXPAND Dao FOREACH  processes»
«EXPAND ModelDao»
«EXPAND AbstractModelDao»
«ENDDEFINE»

«DEFINE Dao FOR Process»
«FILE daoFilename(this) IMPL»
«EXPAND utility::Header»
package «daoPackageOf(this)»;

import javax.ejb.Stateless;
import javax.interceptor.Interceptors;
import de.itemis.jee6.util.Profiler;

@Stateless
@Interceptors(Profiler.class)
public class «daoOf(this)» extends
«IF hasAbstractDao()»
«abstractDaoOf(this)»
«ELSE»
«abstractDaoOf(getModel())»
«ENDIF»
{
}
«ENDFILE»
«ENDDEFINE»

«DEFINE AbstractDao FOR Process»
«IF hasAbstractDao()»
«FILE abstractDaoFilename(this)»
«EXPAND utility::Header»
package «daoPackageOf(this)»;

«IF properties.size > 0»
import javax.annotation.Resource;
«ENDIF»

«IF entities.size > 0»
import «packageOf(entities.first())».*;
«IF entities.types.exists(e|isMany(e))»
import java.util.List;
import javax.persistence.TypedQuery;
«ENDIF»
«ENDIF»

abstract public class «abstractDaoOf(this)» extends «abstractDaoOf(getModel())»
{
«FOREACH properties AS property»
	@Resource(mappedName="«property.jndi»")
	private «typeOf(property)» «nameOf(property)-»«EXPAND Default FOR property-»;
	
	public «typeOf(property)» «getterOf(property)»()
	{
		return this.«nameOf(property)»;
	}
«ENDFOREACH»

«FOREACH entities AS entity»
	/*********************************************
	 * «typeOf(entity)» «nameOf(entity)»
	 *********************************************/
	public void «adder(entity)»(final «typeOf(entity)» «parameterOf(entity)»)
	{
		em.persist(«parameterOf(entity)»);
	}

	public «typeOf(entity)» «updater(entity)»(final «typeOf(entity)» «parameterOf(entity)»)
	{
		return em.merge(«parameterOf(entity)»);
	}

	public void «remover(entity)»(«typeOf(entity)» «parameterOf(entity)»)
	{
«EXPAND GetReference(entity)»
		em.remove(«parameterOf(entity)»);
	}

«FOREACH entity.types.select(e|isMany(e)) AS type»
	public «typeOf(type)» «adderTo(entity)»(«typeOf(entity)» «parameterOf(entity)», final «typeOf(type)» «parameterOf(type)»)
	{
«EXPAND GetReference(entity)»

		// Link new «nameOf(type)»
		«parameterOf(type)».«setterOf(entity)»(«parameterOf(entity)»);
		«parameterOf(entity)».«getterOf(type)»().add(«parameterOf(type)»);
«IF History.isInstance(type)»
		«parameterOf(entity)».setLast(«parameterOf(type)»);
«ENDIF»		
		// Update into database
		em.persist(«parameterOf(type)»);

		return «parameterOf(type)»;
	}

«IF !History.isInstance(type)»
	public «typeOf(entity)» «removerFrom(entity)»(«typeOf(type)» «parameterOf(type)»)
	{
«EXPAND GetReference((EntityRef)type)»
		final «typeOf(entity)» «parameterOf(entity)» = «parameterOf(type)».«getterOf(entity)»();
		
		// Unlink
		«parameterOf(entity)».«getterOf(type)»().remove(«parameterOf(type)»);
		«parameterOf(type)».«setterOf(entity)»(null);

		// finally do database operations
		em.remove(«parameterOf(type)»);
		return «parameterOf(entity)»;
	}
«ENDIF»

	public List<«typeOf(type)»> «lister(type)»(final «typeOf(entity)» «parameterOf(entity)»)
	{
«LET getId(entity) AS id»
«IF id == null»
		final TypedQuery<«typeOf(entity)»> query = em.createQuery(
				"SELECT e FROM «typeOf(entity)» e LEFT JOIN FETCH e.«nameOf(type)» WHERE e.id = :id",
				«typeOf(entity)».class);
		query.setParameter("id", «parameterOf(entity)».getId());
«ELSE»
		final TypedQuery<«typeOf(entity)»> query = em.createQuery(
				"SELECT e FROM «typeOf(entity)» e LEFT JOIN FETCH e.«nameOf(type)» WHERE e.«nameOf(id)» = :«nameOf(id)»",
				«typeOf(entity)».class);
		query.setParameter("«nameOf(id)»", «parameterOf(entity)».«getterOf(id)»());
«ENDIF»
«ENDLET»
		final «typeOf(entity)» result = query.getSingleResult();

		return result.«getterOf(type)»();
	}

«ENDFOREACH»
«ENDFOREACH»
}
«ENDFILE»
«ENDIF»
«ENDDEFINE»

«DEFINE GetReference(Entity entity) FOR Process»
«LET getId(entity) AS id»
		// get correct references
«IF id == null»
		«parameterOf(entity)» = em.getReference(«typeOf(entity)».class, «parameterOf(entity)».getId());
«ELSE»
		«parameterOf(entity)» = em.getReference(«typeOf(entity)».class, «parameterOf(entity)».«getterOf(id)»());
«ENDIF»
«ENDLET»
«ENDDEFINE»

«DEFINE GetReference(EntityRef type) FOR Process»
«LET getId(type.type) AS id»
		// get correct references
«IF id == null»
		«parameterOf(type)» = em.getReference(«typeOf(type)».class, «parameterOf(type)».getId());
«ELSE»
		«parameterOf(type)» = em.getReference(«typeOf(type)».class, «parameterOf(type)».«getterOf(id)»());
«ENDIF»
«ENDLET»
«ENDDEFINE»

«DEFINE ModelDao FOR Model»
«FILE daoFilename(this)»
«EXPAND utility::Header»
package «daoPackageOf(this)»;

import javax.ejb.Stateless;
import javax.interceptor.Interceptors;
import de.itemis.jee6.util.Profiler;

@Stateless
@Interceptors(Profiler.class)
public class «daoOf(this)» extends «abstractDaoOf(this)»
{
}
«ENDFILE»
«ENDDEFINE»

«DEFINE AbstractModelDao FOR Model»
«FILE abstractDaoFilename(this)»
«LET entities.typeSelect(Options) AS converterList»
«EXPAND utility::Header»
package «daoPackageOf(this)»;

import javax.persistence.*;


«IF converterList.size > 0»
import java.util.List;
«FOREACH converterList AS option»
import «fqTypeOf(option)»;
«IF isEnumeration(option)»
import «fqTypeOf(option)».«enumOf(option)»;
«ENDIF»
«ENDFOREACH»
«ENDIF»

abstract public class «abstractDaoOf(this)»
{
«FOREACH getPersistenceUnits() AS pu»
	@PersistenceContext(unitName="«pu.persistence»")
	protected EntityManager em;
«ENDFOREACH»

«FOREACH converterList AS option»
	/**********************************
	 * «typeOf(option)»
	 **********************************/
«LET getId(option) AS id»
«IF id == null»
«IF option.keys.size > 0»
	public «typeOf(option)» ensure(final «enumOf(option)» type, final String key)
	{
		«typeOf(option)» option = em.find(«typeOf(option)».class, type.ordinal());
		
		if (option == null)
		{
			option = new «typeOf(option)»(type, key);
			em.persist(option);
		}
		return option;
	}

	public «typeOf(option)» «finderOf(option)»(final «enumOf(option)» type)
	{
		return «finderOf(option)»(type.ordinal());
	}
«ENDIF»

	public «typeOf(option)» «finderOf(option)»(final int id)
«ELSE»
	public «typeOf(option)» «finderOf(option)»(final «typeOf(id)» id)
«ENDIF»
	{
		return em.find(«typeOf(option)».class, id);
	} 

	public List<«typeOf(option)»> «listOf(option)»()
	{
		TypedQuery<«typeOf(option)»> query = em.createQuery(
				"SELECT entity FROM «typeOf(option)» entity",
				«typeOf(option)».class);
		
		return query.getResultList();
	}
«IF hasActivationBoolean(option)»

	public «typeOf(option)» activate(«typeOf(option)» «nameOf(option)», final boolean activation)
	{
«IF id == null»
		«nameOf(option)» = em.getReference(«typeOf(option)».class, «nameOf(option)».getId());
«ELSE»
		«nameOf(option)» = em.getReference(«typeOf(option)».class, «nameOf(option)».«getterOf(id)»());
«ENDIF»
		«nameOf(option)».setActive(activation);
		
		return «nameOf(option)»;
	}

	public List<«typeOf(option)»> «listActiveOf(option)»()
	{
		TypedQuery<«typeOf(option)»> query = em.createQuery(
				"SELECT o FROM «typeOf(option)» o WHERE o.active = TRUE",
				«typeOf(option)».class);
		
		return query.getResultList();
	}
«ENDIF»
«ENDLET»
«ENDFOREACH»
}
«ENDLET»
«ENDFILE»
«ENDDEFINE»

«DEFINE Default FOR jee6::Property»
«REM»
// No default for other JNDI Properties
«ENDREM»
«ENDDEFINE»

«DEFINE Default FOR TextProp»
«IF value != null»
= "«value»"
«ENDIF»
«ENDDEFINE»

«DEFINE Default FOR IntegerProp»
«IF value != null»
= «value»
«ENDIF»
«ENDDEFINE»

«DEFINE Default FOR BooleanProp»
«IF value != null»
= «value»
«ENDIF»
«ENDDEFINE»
