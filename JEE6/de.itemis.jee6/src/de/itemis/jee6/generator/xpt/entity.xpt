«IMPORT jee6»

«EXTENSION de::itemis::jee6::generator::ext::types»
«EXTENSION de::itemis::jee6::generator::ext::naming»
«EXTENSION de::itemis::jee6::generator::ext::entity»

«DEFINE Main FOR Entity»
«EXPAND Base»
«EXPAND Implementation»
«ENDDEFINE»

«DEFINE Base FOR Entity»
«FILE abstractFilename(this)»
«LET getId() AS id»
package «packageOf(this)»;

import java.io.Serializable;
import java.text.MessageFormat;
import javax.persistence.*;

«IF hasList(this)»
import java.util.List;
«ENDIF»
«FOREACH packages() AS pkg»
import «pkg»;
«ENDFOREACH»

«IF isAbstract()»
@MappedSuperclass
abstract
«ELSE»
@Entity
@Table(name="«typeOf(this)»")
«IF Options.isInstance(this)»
@Cacheable
«ENDIF»
«ENDIF»
public class «abstractOf(this)» implements Serializable
«IF cloneable»
, Cloneable
«ENDIF»
«IF filterable»
, de.itemis.jee6.util.Filterable
«ENDIF»
{
	private static final long serialVersionUID = 1L;

«EXPAND Id(id)»
«EXPAND GetterSetter»
«EXPAND Automatic»
«EXPAND Cloneable(id)»
«EXPAND Sorting(id)»

	@Override
	public String toString()
	{
		StringBuffer buffer = new StringBuffer();
«FOREACH types.typeSelect(Simple).reject(s|isId(s)) AS a»
		buffer.append(" «nameOf(a)»=").append(«getterOf(a)»());
«ENDFOREACH»
		return MessageFormat.format("[«typeOf()»:{0}]{1}",
«IF id == null»
			getId(),
«ELSE»
			«getterOf(id)»(),
«ENDIF»
			buffer);
	}
}
«ENDLET»
«ENDFILE»
«ENDDEFINE»
«DEFINE Implementation FOR Entity»
«IF isAbstract()»
«FILE filename(this) IMPL»
package «packageOf(this)»;

import javax.persistence.*;
«IF filterable»
import java.util.Locale;
«ENDIF»

@Entity
@Inheritance(strategy=InheritanceType.SINGLE_TABLE)
@Table(name="«typeOf(this)»")
«IF Options.isInstance(this)»
@Cacheable
«ENDIF»
public class «typeOf()» extends «abstractOf()»
{
	private static final long serialVersionUID = 1L;

«FOREACH types.select(e|isTransient(e)) AS property»
	@Transient
	@Override
	public «typeOf(property)» «getterOf(property)»()
	{
		// TODO: Implement!
		throw new IllegalStateException("«fqTypeOf()».«getterOf(property)»() not implemented!");
	}
«ENDFOREACH»
«IF filterable»
	@Override
	public boolean filter(final String pattern, final Locale locale) {
		// TODO: Auto-generated method stub
		return false;
	}
«ENDIF»
}
«ENDFILE»
«ENDIF»
«ENDDEFINE»

«DEFINE Id(Attribute id) FOR Entity»
«ENDDEFINE»

«DEFINE Id(Attribute id) FOR Options»
«IF keys.size > 0»
	public static enum «enumOf(this)»
	{
«FOREACH keys AS key SEPARATOR ","»
	«key.toUpperCase().replaceAll("\\.", "_")»
«ENDFOREACH»
	}

	public «abstractOf()»()
	{
	}

«IF id == null»
	public «abstractOf()»(final «enumOf(this)» type, final String bundleKey)
	{
		this(type.ordinal(), bundleKey);
	}

	public «abstractOf()»(final int id, final String bundleKey)
	{
		setId(id);
		setBundleKey(bundleKey);
	}
	private int    id;

	@Id
	public int getId() {
		return this.id;
	}

	public void setId(final int id) {
		this.id = id;
	}

	@Transient
	public «enumOf(this)» get«enumOf(this)»()
	{
		return «enumOf(this)».values()[getId()];
	}
«ELSE»
	public «abstractOf()»(final «typeOf(id)» «nameOf(id)», final String bundleKey)
	{
		setId(«nameOf(id)»);
		setKey(bundleKey);
	}
«ENDIF»

	private String bundleKey;

	@Column
	@javax.validation.constraints.NotNull
	public String getBundleKey() {
		return this.bundleKey;
	}

	public void setBundleKey(final String bundleKey) {
		this.bundleKey = bundleKey;
	}
«ELSE»
«IF id == null»
	private int id;

	@Id
	@TableGenerator(
			name="«typeOf(this)»IDs", table = "IDs",
			pkColumnName = "id", valueColumnName = "value", pkColumnValue = "«typeOf(this)»",
			initialValue = 1, allocationSize = 10)
	@GeneratedValue(strategy=GenerationType.TABLE, generator="«typeOf(this)»IDs")
	public int getId() {
		return id;
	}

	public void setId(final int id) {
		this.id = id;
	}
«ENDIF»
«ENDIF»
«ENDDEFINE»

«DEFINE Id(Attribute id) FOR Table»
«IF id == null»
	private int id;

	@Id
	@TableGenerator(
			name="«typeOf(this)»IDs", table = "IDs",
			pkColumnName = "id", valueColumnName = "value", pkColumnValue = "«typeOf(this)»",
			initialValue = 1, allocationSize = 10)
	@GeneratedValue(strategy=GenerationType.TABLE, generator="«typeOf(this)»IDs")
	public int getId() {
		return id;
	}

	public void setId(final int id) {
		this.id = id;
	}
«ENDIF»
«ENDDEFINE»

«DEFINE Property FOR Attribute»
«IF isTransient()»
	@Transient
	public abstract «relationOfType()» «getterOf()»();
«ELSE»
	private «relationOfType()» «nameOf()»;

«IF isId()»
	@Id
«ELSE»
	«annotationOf()»
«ENDIF»
	public «relationOfType()» «getterOf()»()
	{
		return this.«nameOf()»;
	}

	public void «setterOf()»(final «relationOfType()» «nameOf()»)
	{
		this.«nameOf()» = «nameOf()»;
	}
«ENDIF»
«ENDDEFINE»

«DEFINE Property FOR Entity»
	private «typeOf()» «nameOf()»;

	@ManyToOne
	public «typeOf()» «getterOf()»()
	{
		return this.«nameOf()»;
	}

	public void «setterOf()»(final «typeOf()» «nameOf()»)
	{
		this.«nameOf()» = «nameOf()»;
	}
«ENDDEFINE»

«DEFINE GetterSetter FOR Entity»
«EXPAND Property FOREACH types»
«EXPAND Property FOREACH getEntityReferences()»
«LET getHistory() AS history»
«IF history != null»
	private «typeOf(history)» last;
	
	@OneToOne
	public «typeOf(history)» getLast()
	{
		return this.last;
	}

	public void setLast(final «typeOf(history)» last)
	{
		this.last = last;
	}
«ENDIF»
«ENDLET»
«ENDDEFINE»

«DEFINE Sorting(Attribute id) FOR Entity»
«ENDDEFINE»

«DEFINE Automatic FOR Entity»
«LET types.typeSelect(Timestamp).select(e|e.auto) AS auto»
«IF auto.size > 0»
	@PrePersist
	public void prePersist()
	{
«FOREACH auto AS date»
		if («getterOf(date)»() == null)
		{
			«setterOf(date)»(new Date());
		}
«ENDFOREACH»
	}
«ENDIF»
«ENDLET»

«LET types.typeSelect(Timestamp).select(e|e.update) AS update»
«IF update.size > 0»
	@PreUpdate
	public void preUpdate()
	{
«FOREACH update AS date»
		«setterOf(date)»(new Date());
«ENDFOREACH»
	}
«ENDIF»
«ENDLET»
«ENDDEFINE»

«DEFINE Sorting(Attribute id) FOR Options»
	@Override
	public int hashCode()
	{
		return super.hashCode();
	}

	@Override
	public boolean equals(final Object object)
	{
		if ((object == null) || !(object instanceof «typeOf(this)»))
		{
			return false;
		}
		«typeOf(this)» option = («typeOf(this)»)object;
«IF id == null»
		return getId() == option.getId();
«ELSE»
		return «getterOf(id)»().equals(option.«getterOf(id)»());
«ENDIF»
	}
«ENDDEFINE»

«DEFINE Cloneable(Attribute id) FOR Entity»
«IF cloneable»
	@Override
	public «typeOf(this)» clone()
	{
		try
		{
			«typeOf(this)» «nameOf(this)» = («typeOf(this)»)super.clone();
«IF id == null»
			«nameOf(this)».setId(0);
«ELSE»
			«nameOf(this)».«setterOf(id)»(null);
«ENDIF»
			return «nameOf(this)»;
		}
		catch (CloneNotSupportedException cnse)
		{
			return null;
		}
	}
«ENDIF»
«ENDDEFINE»

