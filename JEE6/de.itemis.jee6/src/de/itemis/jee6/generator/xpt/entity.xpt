«IMPORT jee6»

«EXTENSION de::itemis::jee6::generator::ext::types»
«EXTENSION de::itemis::jee6::generator::ext::naming»
«EXTENSION de::itemis::jee6::generator::ext::entity»

«DEFINE Main FOR Entity»
«EXPAND Base»
«EXPAND Implementation»
«ENDDEFINE»

«DEFINE Base FOR Entity»
«FILE abstractFilename(this)»
«LET getId() AS id»
package «packageOf(this)»;

import java.io.Serializable;
import java.text.MessageFormat;
import javax.persistence.*;

«IF hasList(this)»
import java.util.List;
«ENDIF»
«IF filterable»
import java.util.Locale;
«ENDIF»
«FOREACH packages() AS pkg»
import «pkg»;
«ENDFOREACH»

«IF isAbstract()»
@MappedSuperclass
abstract
«ELSE»
@Entity
@Table(name="«typeOf(this)»")
«ENDIF»
public class «abstractOf(this)» implements Serializable
«IF cloneable»
, Cloneable
«ENDIF»
«IF filterable»
, de.itemis.jee6.util.Filterable
«ENDIF»
{
	private static final long serialVersionUID = 1L;

«EXPAND Id»
«EXPAND GetterSetter»

«LET types.typeSelect(Timestamp).select(e|e.auto) AS auto»
«IF auto.size > 0»
	@PrePersist
	public void prePersist()
	{
«FOREACH auto AS date»
		if («getterOf(date)»() == null)
		{
			«setterOf(date)»(new Date());
		}
«ENDFOREACH»
	}
«ENDIF»
«ENDLET»

«LET types.typeSelect(Timestamp).select(e|e.update) AS update»
«IF update.size > 0»
	@PreUpdate
	public void preUpdate()
	{
«FOREACH update AS date»
		«setterOf(date)»(new Date());
«ENDFOREACH»
	}
«ENDIF»
«ENDLET»

«EXPAND Sorting»

«IF cloneable»
	@Override
	public «typeOf(this)» clone()
	{
		try
		{
			«typeOf(this)» «nameOf(this)» = («typeOf(this)»)super.clone();
«IF id == null»
			«nameOf(this)».setId(0);
«ELSE»
			«nameOf(this)».«setterOf(id)»(null);
«ENDIF»
			return «nameOf(this)»;
		}
		catch (CloneNotSupportedException cnse)
		{
			return null;
		}
	}
«ENDIF»

	@Override
	public String toString()
	{
		StringBuffer buffer = new StringBuffer();
«FOREACH types.typeSelect(Simple).reject(s|isId(s)) AS a»
		buffer.append(" «nameOf(a)»=").append(«getterOf(a)»());
«ENDFOREACH»
		return MessageFormat.format("[«typeOf()»:{0}]{1}",
«IF id == null»
			getId(),
«ELSE»
			«getterOf(id)»(),
«ENDIF»
			buffer);
	}
}
«ENDLET»
«ENDFILE»
«ENDDEFINE»

«DEFINE Id FOR Entity»
«ENDDEFINE»

«DEFINE Property FOR Attribute»
«IF isTransient()»
	@Transient
	public abstract «relationOfType()» «getterOf()»();
«ELSE»
	private «relationOfType()» «nameOf()»;

«IF isId()»
	@Id
«ELSE»
	«annotationOf()»
«ENDIF»
	public «relationOfType()» «getterOf()»()
	{
		return this.«nameOf()»;
	}

	public void «setterOf()»(final «relationOfType()» «nameOf()»)
	{
		this.«nameOf()» = «nameOf()»;
	}
«ENDIF»
«ENDDEFINE»

«DEFINE Property FOR Entity»
	private «typeOf()» «nameOf()»;

	@ManyToOne
	public «typeOf()» «getterOf()»()
	{
		return this.«nameOf()»;
	}

	public void «setterOf()»(final «typeOf()» «nameOf()»)
	{
		this.«nameOf()» = «nameOf()»;
	}
«ENDDEFINE»

«DEFINE GetterSetter FOR Entity»
«EXPAND Property FOREACH types»
«EXPAND Property FOREACH getEntityReferences()»
«ENDDEFINE»

«DEFINE Sorting FOR Entity»
«ENDDEFINE»

«DEFINE Id FOR Options»
«IF keys.size > 0»
	public static enum Type
	{
«FOREACH keys AS key SEPARATOR ","»
	«key.toUpperCase().replaceAll("\\.", "_")»
«ENDFOREACH»
	}

	private String key;

	@Column
	public String getKey() {
		return this.key;
	}

	public void setKey(final String key) {
		this.key = key;
	}
«ENDIF»

«IF !types.exists(e|isId(e))»
	private int    id;

	@Id
	public int getId() {
		return this.id;
	}

	public void setId(final int id) {
		this.id = id;
	}
«ENDIF»
«ENDDEFINE»

«DEFINE Id FOR Table»
«IF !types.exists(e|isId(e))»
	private int id;

	@Id
	@TableGenerator(
			name="«typeOf(this)»IDs", table = "IDs",
			pkColumnName = "id", valueColumnName = "value", pkColumnValue = "«typeOf(this)»",
			initialValue = 1, allocationSize = 10)
	@GeneratedValue(strategy=GenerationType.TABLE, generator="«typeOf(this)»IDs")
	public int getId() {
		return id;
	}

	public void setId(final int id) {
		this.id = id;
	}
«ENDIF»
«ENDDEFINE»

«DEFINE Sorting FOR Options»
	@Override
	public int hashCode()
	{
		return super.hashCode();
	}

	@Override
	public boolean equals(final Object object)
	{
		if ((object == null) || !(object instanceof «typeOf(this)»))
		{
			return false;
		}
		«typeOf(this)» option = («typeOf(this)»)object;
«LET getId() AS id»
«IF id == null»
		return getId() == option.getId();
«ELSE»
		return «getterOf(id)»().equals(option.«getterOf(id)»());
«ENDIF»
«ENDLET»
	}
«ENDDEFINE»

«DEFINE Implementation FOR Entity»
«IF isAbstract()»
«FILE filename(this) IMPL»
package «packageOf(this)»;

import javax.persistence.*;
«IF filterable»
import java.util.Locale;
«ENDIF»

@Entity
@Inheritance(strategy=InheritanceType.SINGLE_TABLE)
@Table(name="«typeOf(this)»")
public class «typeOf()» extends «abstractOf()»
{
	private static final long serialVersionUID = 1L;

«FOREACH types.select(e|isTransient(e)) AS property»
	@Transient
	@Override
	public «typeOf(property)» «getterOf(property)»()
	{
		// TODO: Implement!
		throw new IllegalStateException("«fqTypeOf()».«getterOf(property)»() not implemented!");
	}
«ENDFOREACH»
«IF filterable»
	@Override
	public boolean filter(final String pattern, final Locale locale) {
		// TODO: Auto-generated method stub
		return false;
	}
«ENDIF»
}
«ENDFILE»
«ENDIF»
«ENDDEFINE»
